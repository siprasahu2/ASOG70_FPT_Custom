#Thu Jan 02 17:39:43 IST 2025
[condition][]the_field {tagValue} is populated as per specified TLV format from positions 1 12 =((new Position()).formatCheckForFields1_12({tagValue}))
[condition][]virtualoccurenceofuactRuid {vector} {list} {errorcode} =((new Occurence(xcb.getXmlInstance())).virtauloccurenceofuactRuid({vector},{list},{errorcode}))
[condition][]it is not true that_tagValue {var0} =((new Occurence(xcb.getXmlInstance())).tagValue({var0}))
[condition][]the {field} from {pos1} to {pos2} of the segment{segnum} has_the comma seperated values{values} to support virgule or period as delimiter=((new LengthCheck()).virguleandPeriodPosToPosOfSegmentNotEquals((xcb.xpath({field})).stringValue(),{pos1},{pos2},{segnum},{values}))
[condition][]it is not true that_the {field} doesnot have {N} number of segments=(!((new LengthCheck()).fieldDoesNothaveNumberOfSegments((xcb.xpath({field})).stringValue(),{N})))
[condition][]the {field} contains {num} of spaces before Alpha Characters=((new CapitalLetterCheck()).containsConsecutiveSpacesBeforeAlphaCharacters((xcb.xpath({field})).stringValue(),{num}))
[condition][]display the message {field}=((new DisplayMessage()).displayMessage((xcb.xpath({field})).stringValue()))
[condition][]the {field} has_comma seperated values=((new CommaSeparatedSpace()).checkCommaSeparatedSpace((xcb.xpath({field})).stringValue()))
[condition][]the {field} is Numeric with Special Characters=((new DatatypeCheck()).checkNumericSP((xcb.xpath({field})).stringValue()))
[condition][]the_length_of {field} is_equal_to {value}=((new LengthCheck()).checkLength((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_virguleandPeriodSegmentValueEqualToValues {var0} {var1} {var2} =(!((new Equals()).virguleandPeriodSegmentValueEqualToValues({var0},{var1},{var2})))
[condition][]virtualoccurenceofSvlanMppingfortwoocc {Vector} {errorcode} =(virtualoccurenceofSvlanMppingfortwoocc({Vector},{errorcode}))
[condition][]it is not true that_the {field} has_the segment with specified {segnum} whose length is greater than specified {length} to support virgule or period=(!((new LengthCheck()).virguleandPeriodSegmentNumberLengthGreaterThan((xcb.xpath({field})).stringValue(),{segnum},{length})))
[condition][]the {field} has_specified {segmentNumber} not_equal_to space=((new DatatypeCheck()).segmentNotEqualToSpace((xcb.xpath({field})).stringValue(),{segmentNumber}))
[condition][]the {field} does not match with {field2} at the specified character positions {pos1} to {pos2}=((new Position()).compStringDoesntMatchTagValueAtSpecPosition((xcb.xpath({field})).stringValue(),{field2},{pos1},{pos2}))
[condition][]it is not true that_the {field} has_none valid values {commaseperatedvalues}=(!((new isValidValue()).isNoneValidValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]the {field} is in the range ZL1 to ZL8=((new RangeOfValues()).rangeCheckZl1_Zl8((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} has_a space which is followed by numeric=(!((new SpaceCheck()).spaceFollowedByNumeric((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is lesser than {pos} and {pos} position=(!((new Position()).twoPositionValueofTagIsLessThanTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]it is not true that_setSvcName {var0} =(!((new SvcType()).setSvcName({var0})))
[condition][]the {pos} and {pos} position_of the {field} is lesser than {pos} and {pos} position=((new Position()).twoPositionValueofTagIsLessThanTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]the_fields NC {NC} NCI {NCI} and SECNCI {SECNCI} are not compatible with database=((new ASOGTABLE()).checkNcNciCompatibility({NC},{NCI},{SECNCI}))
[condition][]it is not true that_the {field} is AlphaNumeric with following Special Character set {setofspecialcharacters}=(!((new DatatypeCheck()).checkAlphaNumericSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters})))
[condition][]the version is {VER} not_equal_to the latest database version for the pon {PON} ccna {CCNA} and icsc{ICSC} with the status {STATUS}=((new SuplementOrderCheck()).verNotEqualToLatestDBVersion((xcb.xpath({VER})).stringValue(),(xcb.xpath({PON})).stringValue(),(xcb.xpath({CCNA})).stringValue(),{ICSC},{STATUS}))
[condition][]it is not true that_spaceOrCharacterOrNumberInRange01_99 {var0} {var1} {var2} {var3} {var4} =(!((new Position()).spaceOrCharacterOrNumberInRange01_99({var0},{var1},{var2},{var3},{var4})))
[condition][]it is not true that_checkAnyPositionsInRangeContainsValues {var0} {var1} {var2} {var3} =(!((new Position()).checkAnyPositionsInRangeContainsValues({var0},{var1},{var2},{var3})))
[condition][]it is not true that_the {field} is Alpha without Special Characters Set {setofspecialcharacters}=(!((new DatatypeCheck()).checkAlphaWithOutSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters})))
[condition][]virtualisIntervalDurationMatchingForNc {var0} {var1} =(virtualisIntervalDurationMatchingForNc({var0},{var1}))
[condition][]it is not true that_the {field} from {pos1} to {pos2} of the segment{segnum} are not alpha characters to supportvirgule or period as delimiter=(!((new LengthCheck()).virguleandPeriodPosToPosOfSegmentAreNotAlpha((xcb.xpath({field})).stringValue(),{pos1},{pos2},{segnum})))
[condition][]Request PON{pon} VER{ver} CCNA{ccna} ICSC{icsc} exists in DB=((new SuplementOrderCheck()).checkRequestExistsInDatabase((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc}))
[condition][]setNCLicense {var0} =((new SvcType()).setNCLicense({var0}))
[condition][]it is not true that_valueOfFieldIsEqualToccurenceOfAnotherField {var0} {var1} =((new Occurence(xcb.getXmlInstance())).valueOfFieldIsEqualToccurenceOfAnotherField({var0},{var1}))
[condition][]it is not true that_the {field} is populated=(!((new Populated()).isPopulated((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the interface name does not exist=(!((new SuplementOrderCheck()).checkInterfaceId()))
[condition][]it is not true that_the {field} has_date format as {format}=(!((new DateFormatCheck()).dateCheck((xcb.xpath({field})).stringValue(),{format})))
[condition][]it is not true that_the {field} is AlphaNumeric with only space as special character=(!((new DatatypeCheck()).checkAlphaNumericWithSpaceAsSpecialCharacter((xcb.xpath({field})).stringValue())))
[condition][]ccnaMultiEcIcscCheck {var0} {var1} {var2} =((new SuplementOrderCheck()).ccnaMultiEcIcscCheck({var0},{var1},{var2}))
[condition][]the substring upto colon of the {field} equals {values}=((new SvcType()).compareSvcType((xcb.xpath({field})).stringValue(),{values}))
[condition][]Is the {fieldDate1} not_equal_to {comparisonDate} in the format {CCYYMMDD}=((new DateFormatCheck()).isFieldNotEqualToComparisonDateInspecifiedFormat({fieldDate1},{comparisonDate},{CCYYMMDD}))
[condition][]the {fieldName} in {parentSection} is less than {fieldValue} for the {pon} {ver} {ccna} {icsc}=((new SuplementOrderCheck()).isCurrentDDDLessThanPreviousVersionDDD({fieldName},{parentSection},{fieldValue},(xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc}))
[condition][]the_field {field} with space in range {start} and {end}=((new SpaceCheck()).existenceOfSpaceInSpecRange((xcb.xpath({field})).stringValue(),{start},{end}))
[condition][]it is not true that_the {field} has_a valid value {value}=(!((new isValidValue()).isValidValue((xcb.xpath({field})).stringValue(),{value})))
[condition][]the {fielddate1} is_not_equal_to {fielddate2}=((new DateCheck()).isNotEqualTo({fielddate1},{fielddate2}))
[condition][]the {fieldwithxpath} is not required=((new Required()).isNotRequired({fieldwithxpath}))
[condition][]it is not true that_virtualoccurenceofVACTandUACT3 {section} {errorcode} =(!(virtualoccurenceofVACTandUACT3({section},{errorcode})))
[condition][]fieldPositionInRange {var0} {var1} {var2} {var3} =((new RangeOfValues()).fieldPositionInRange({var0},{var1},{var2},{var3}))
[condition][]the {field} contains all lowercase alpha character directly preceded by a numeric character=((new CapitalLetterCheck()).lowercaseAlphapreceededByNumeric((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {fieldvalue} is present in the LOCATION table=(!((new ASOGTABLE()).fetchAbbreviationLOCATIONTable({fieldvalue})))
[condition][]the {field} is AlphaNumeric without following Special Character set {setofspecialcharacters}=((new DatatypeCheck()).checkAlphaNumericWithOutSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters}))
[condition][]the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} and qty {QtyFieldValue} on the current order which has_decreasing QTY with respect to the previous order=((new SuplementOrderCheck()).qtyFieldCheck({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue},{QtyFieldValue}))
[condition][]set the request type of to {var0}=((new ReqTypeAct()).setRequestType({var0}))
[condition][]the {field} is AlphaNumeric with Special Characters=((new DatatypeCheck()).checkAlphaNumericSP((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} has_not a valid value{commaseperatedvalues}=(!((new isValidValue()).isNotValidValue((xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]checkCapsInField2ForPosInField1 {var0} {var1} {var2} =((new CapitalLetterCheck()).checkCapsInField2ForPosInField1({var0},{var1},{var2}))
[condition][]the {pos} and {pos} position_of the {field} is_equal_to {pos} and {pos} position=((new Position()).twoPositionValueofTagEqualToValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]the{section}{field}is populated and assosiated tag{tag} not_equals to values{values}=(virtualAnyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues({section},{field},{tag},{values}))
[condition][]it is not true that_ccnaMultiEcIcscCheck {var0} {var1} {var2} =(!((new SuplementOrderCheck()).ccnaMultiEcIcscCheck({var0},{var1},{var2})))
[condition][]the ICSC has_license for CLLI Table=((new SvcType()).getIcscCLLILicense())
[condition][]it is not true that_the {field} has_the specified segment with number {segnum} whose length is less than specified {length}=(!((new LengthCheck()).segmentNumberLengthLessThan((xcb.xpath({field})).stringValue(),{segnum},{length})))
[condition][]it is not true that_the occurance of {fieldwithxpath} is less than {number}=((new Occurence(xcb.getXmlInstance())).noOfOccurenceLessThan({fieldwithxpath},{number}))
[condition][]the {fieldvalue} is present in NCMUX table =((new ASOGTABLE()).fetchAbbreviationNCMUXTable({fieldvalue}))
[condition][]it is not true that_the {fieldvalue} not_equal_to specified values {CommaSeparatedValues} of the specified {segnum}=(!((new Equals()).segmentValueNotEqualToValues({fieldvalue},{CommaSeparatedValues},{segnum})))
[condition][]positionOfStringInSpecifiedRange {var0} {var1} {var2} {var3} =((new RangeOfValues()).PositionOfStringInSpecifiedRange({var0},{var1},{var2},{var3}))
[condition][]it is not true that_Spec_Lrefchk{Lref} Lref{lref} spec{spec} and occurance{occurance} with errorCode {errorcode}=(!(virtualSpecLrefchk({Lref},{lref},{spec},{occurance},{errorcode})))
[condition][]virtualoccOfOTCnEVMPIDwithinsameUNIMAPPING {section} {errorcode} =(virtualoccOfOTCnEVMPIDwithinsameUNIMAPPING({section},{errorcode}))
[condition][]the {field} has {count} comma separated values=((new CommaSeparatedSpace()).countCommaSeperatedValues((xcb.xpath({field})).stringValue(),{count}))
[condition][]it is not true that_the occurance of {fieldwithxpath} is greaterthan {number}=((new Occurence(xcb.getXmlInstance())).noOfOccurenceGreaterThan({fieldwithxpath},{number}))
[condition][]it is not true that_the difference between {fielddate1} and {fielddate2} is less than or equal to one year=(!((new DateCheck()).isRangeLesserThanOrEqualToOneYear({fielddate1},{fielddate2})))
[condition][]the_field {fieldname} with parent section {parentname} is populated in previous version for the pon {PON} ver {VER} ccna {CCNA} and icsc {ICSC}=((new SuplementOrderCheck()).fieldPopulatedInPreviousVersion({fieldname},{parentname},(xcb.xpath({PON})).stringValue(),(xcb.xpath({VER})).stringValue(),(xcb.xpath({CCNA})).stringValue(),{ICSC}))
[condition][]the multiple field {field} is not numeric in any occurence=((new Occurence(xcb.getXmlInstance())).dataTypeCheckForMultipleOccuringTag({field}))
[condition][]it is not true that_the position {pos} of {field} is_not_equal_to_values {commaseperatedvalues}=(!((new Position()).positionOftagValueNotEqualToValues({pos},(xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]it is not true that_the {fielddate1} is a Holiday=(!((new DateCheck()).isInHolidayList({fielddate1})))
[condition][]setNCNCICompatibilityLicense  {var0} =((new SvcType()).setNCNCICompatibilityLicense({var0}))
[condition][]virtualSegmentCount {var0} =(virtualSegmentCount({var0}))
[condition][]the {field} does not match with {compstring} having the specified Characters {numChar} from last within the comparison string=((new Position()).CompStringDoesntMatchWithSpecifiedChars((xcb.xpath({field})).stringValue(),{compstring},{numChar}))
[condition][]it is not true that_occurenceOfFieldIsGreaterThanSpecifiedNumberWithGivenValue {var0} {var1} {var2} =((new Occurence(xcb.getXmlInstance())).occurenceOfFieldIsGreaterThanSpecifiedNumberWithGivenValue({var0},{var1},{var2}))
[condition][]it is not true that_any occurence of the {fieldwithxpath} is_not_populated in Response=((new Occurence(xcb.getXmlInstance())).anyOccurenceOfFieldNotPopulatedinResponse({fieldwithxpath}))
[condition][]it is not true that_anyARIPrilocAndPrilocSpotCheck {var0} {var1} {var2} =((new Occurence(xcb.getXmlInstance())).anyARIPrilocAndPrilocSpotCheck({var0},{var1},{var2}))
[condition][]the_field {field} is not numeric from postion {posn1} to position {posn2}=((new Contains()).positionalNotNumeric((xcb.xpath({field})).stringValue(),{posn1},{posn2}))
[condition][]it is not true that_the_section{section} parent{parent} tag {tag} has_value{value} in any occurence=(!(virtualAnyOccurenceOfSaliTagEqualsValue({section},{parent},{tag},{value})))
[condition][]positionOfAllFieldNotEqualToCharacter {var0} {var1} {var2} =((new Occurence(xcb.getXmlInstance())).positionOfAllFieldNotEqualToCharacter({var0},{var1},{var2}))
[condition][]the interval between {fielddate1} and {fielddate2} is less than or equal to {days}=((new DateCheck()).intervalBetweenTwoDateIsLessThanOrEqualtoDays({fielddate1},{fielddate2},{days}))
[condition][]checkAnyPositionsInRangeContainsValues {var0} {var1} {var2} {var3} =((new Position()).checkAnyPositionsInRangeContainsValues({var0},{var1},{var2},{var3}))
[condition][]setIcscCLLILicense {var0} =((new SvcType()).setIcscCLLILicense({var0}))
[condition][]it is not true that_the{section}{field} is not numerics with {errorcode}=((new Occurence(xcb.getXmlInstance())).VirtualResponseDataTypeNumericCheck({section},{field},{errorcode}))
[condition][]it is not true that_the {field} is Alpha with Special Characters=(!((new DatatypeCheck()).checkAlphaSP((xcb.xpath({field})).stringValue())))
[condition][]The{field}matches with{compString}having the specified characters{numChar} from last within the comparison string=((new Position()).compnoOfCharAtLastWithTagValueAsPerCompString((xcb.xpath({field})).stringValue(),{compString},{numChar}))
[condition][]it is not true that_the {field} has_specified range {start} to {end}=(!((new RangeOfValues()).rangeCheckNN_NN((xcb.xpath({field})).stringValue(),{start},{end})))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is_not_equal_to {pos} and {pos} position=(!((new Position()).twoPositionValueofTagNotEqualToValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} on the current order and matching with the previous order which has_a status COMPLETED=((new SuplementOrderCheck()).completionOrderCheck({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue}))
[condition][]it is not true that_the interval between {fielddate1} and {fielddate2} is_equal_to {days}=(!((new DateCheck()).intervalBetweenTwoDateIsEqualtoDays({fielddate1},{fielddate2},{days})))
[condition][]segact of ARI{ari} {segact} and RING{ring} value check with errorcode {errorcode}=(virtualSegactValueCheck({ari},{segact},{ring},{errorcode}))
[condition][]it is not true that_all occurences of{fieldwithxpath} not_equals to{value}=((new Occurence(xcb.getXmlInstance())).allOccurenceOfFieldNotEqualToValue({fieldwithxpath},{value}))
[condition][]anyOccurenceOfMultipleFieldIsPopulatedAndNotNumeric {var0} =((new Occurence(xcb.getXmlInstance())).anyOccurenceOfMultipleFieldIsPopulatedAndNotNumeric({var0}))
[condition][]it is not true that_getXPathWithPosition {var0} {var1} =(!((new XpathLookup()).getXPathWithPosition({var0},{var1})))
[condition][]the {field} is numeric followed by dot and is followed by numeric=((new RangeOfValues()).isNumericFollowedByDotFollowedByNumeric((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} contains all lowercase alpha characters directly preceded by a numeric character=(!((new CapitalLetterCheck()).lowercaseAlphaCharactersPreceededByNumeric((xcb.xpath({field})).stringValue())))
[condition][]the {field} has_a space which is followed by numeric=((new SpaceCheck()).spaceFollowedByNumeric((xcb.xpath({field})).stringValue()))
[condition][]virguleandPeriodSegmentValueEqualToValues {var0} {var1} {var2} =((new Equals()).virguleandPeriodSegmentValueEqualToValues({var0},{var1},{var2}))
[condition][]it is not true that_the {field} does not contain {CommaSeparatedValues}=(!((new Contains()).doesNotContains((xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]it is not true that_the difference between {fielddate1} and {fielddate2} is_not_equal_to one year=(!((new DateCheck()).isRangeNotEqualToOneYear({fielddate1},{fielddate2})))
[condition][]it is not true that_responseMaximumLengthCheck {var0} {var1} {var2} {var3} =((new Occurence(xcb.getXmlInstance())).responseMaximumLengthCheck({var0},{var1},{var2},{var3}))
[condition][]it is not true that_any occurance{fieldwithxpath}fieldisPopulated=((new Occurence(xcb.getXmlInstance())).anyOccurenceOfFieldPopulated({fieldwithxpath}))
[condition][]the CCNA has_license for CLLI Table=((new SvcType()).getCLLILicense())
[consequence][]setNCILicense {var0} =((new SvcType()).setNCILicense({var0}))
[condition][]it is not true that_the {segnum} segment of the {fieldvalue} is present in the LOCATION Table=(!(virtualSegmentFetchAbbreviationLOCATIONTable({segnum},{fieldvalue})))
[condition][]the {pos} position_Of {field} equal to {value}=((new Contains()).positionOfFieldEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {field} has_comma seperated values=(!((new CommaSeparatedSpace()).checkCommaSeparatedSpace((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} is compared with the specified positions {pos1} to {pos2} with values {value1} or {value2}=(!((new Position()).compareCharAtAnyPositionWithAnyValue((xcb.xpath({field})).stringValue(),{pos1},{pos2},{value1},{value2})))
[condition][]it is not true that_the {field} has_last character as upper which is followed by lower case character=(!((new CapitalLetterCheck()).lastCharUpperFollLower((xcb.xpath({field})).stringValue())))
[condition][]the {field} is NotProhibited=((new Prohibited()).isNotProhibited((xcb.xpath({field})).stringValue()))
[condition][]there is no {field} section=((new Populated()).isNotPopulated((xcb.xpath({field})).stringValue()))
[condition][]the difference between {fielddate1} and {fielddate2} is greater than or equal to one year=((new DateCheck()).isRangeGreaterThanOrEqualToOneYear({fielddate1},{fielddate2}))
[condition][]it is not true that_the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} on the current order and matching with the previous order which has_a status COMPLETED=(!((new SuplementOrderCheck()).completionOrderCheck({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue})))
[condition][]it is not true that_existenceOfSpaceInEntireRange {field} {range1} {range2} =(!((new SpaceCheck()).existenceOfSpaceInEntireRange((xcb.xpath({field})).stringValue(),{range1},{range2})))
[condition][]the interval duration is blank for the {nc}=((new IntervalDurationMatcher()).isIntervalExisting({nc}))
[condition][]the ASR Request order exists for the pon {PON} ccna {CCNA} and icsc {ICSC}=((new SuplementOrderCheck()).checkRequestPonExistsInDatabase((xcb.xpath({PON})).stringValue(),(xcb.xpath({CCNA})).stringValue(),{ICSC}))
[condition][]the {fielddate1} is a valid date=((new DateCheck()).isValidDate({fielddate1}))
[condition][]the {field} is equal or less than {value}=((new Equals()).isEqualOrLessThan((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_setICSCLicense {var0} =(!((new SvcType()).setICSCLicense({var0})))
[condition][]the {field} is populated=((new Populated()).isPopulated((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} is in the range ZL1 to ZL8=(!((new RangeOfValues()).rangeCheckZl1_Zl8((xcb.xpath({field})).stringValue())))
[condition][]the {fieldvalue} not_equal_to specified values {CommaSeparatedValues} of the specified {segnum}=((new Equals()).segmentValueNotEqualToValues({fieldvalue},{CommaSeparatedValues},{segnum}))
[condition][]valueOfFieldIsEqualToccurenceOfAnotherField {var0} {var1} =((new Occurence(xcb.getXmlInstance())).valueOfFieldIsEqualToccurenceOfAnotherField({var0},{var1}))
[condition][]it is not true that_the {field} has_specified {segmentNumber} not_equal_to numeric with virgule or period as delimiter=(!((new DatatypeCheck()).virguleandPeriodSegmentNotEqualToNumeric((xcb.xpath({field})).stringValue(),{segmentNumber})))
[condition][]the {field} is Prohibited=((new Prohibited()).isProhibited((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} has {commaseperatedvalues}=(!((new ValidValueCheck()).validCommaSeperatedValue((xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]the {field} has_specified segment {segnum} which has_the specified alpha {specAlpha}=((new DatatypeCheck()).segmentNotEqualToSpecifiedAlpha((xcb.xpath({field})).stringValue(),{segnum},{specAlpha}))
[condition][]it is not true that_virtualoccOfF1nF2andVAL1nVAL2withinsameUNIMAPPING {section} {errorcode} {field1} {F1values} {field2} {F2values} {field3} =(!(virtualoccOfF1nF2andVAL1nVAL2withinsameUNIMAPPING({section},{errorcode},{field1},{F1values},{field2},{F2values},{field3})))
[condition][]the minimum length of {field} is {value}=((new LengthCheck()).checkMinimumLength((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_lrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues {var0} {var1} {var2} {var3} {var4} {var5} {var6} =((new Occurence(xcb.getXmlInstance())).lrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]the {fieldwithxpath} is required=((new Required()).isRequired({fieldwithxpath}))
[consequence][]setNCNCICompatibilityLicense  {var0} =((new SvcType()).setNCNCICompatibilityLicense({var0}))
[condition][]it is not true that_the each position_from {pos1} to {pos2} of {field} is_not_equal_to_values{commaseperatedvalues}=(!((new Position()).checkEachPositionsInRangeNotEqualToValues({pos1},{pos2},(xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]it is not true that_the {field} has_ampersand which is not preceeded and followed by space=(!((new SpaceCheck()).isAmpersandNotPrecFollSpace((xcb.xpath({field})).stringValue())))
[condition][]tagValueEqualsInPreviousVersion {var0} {var1} {var2} {var3} {var4} {var5} {var6} =((new SuplementOrderCheck()).tagValueEqualsInPreviousVersion({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is greater than or equal to {pos} and {pos} position=(!((new Position()).twoPositionValueofTagIsGreaterThanOrEqualToTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]it is not true that_the interval duration is blank for the {nc}=(!((new IntervalDurationMatcher()).isIntervalExisting({nc})))
[condition][]it is not true that_the {pos} and {pos} of {field} is_equal_to_values {CommaSeparatedValues}=(!((new Position()).twoPositionValueofTagEqualToValues({pos},{pos},(xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]it is not true that_timeRange {var0} {var1} {var2} =(!((new TimeFormatCheck()).timeRange({var0},{var1},{var2})))
[condition][]the range of the {field} is A0 to Z9=((new RangeOfValues()).rangeCheckA0_Z9((xcb.xpath({field})).stringValue()))
[condition][]the {fielddate1} is_equal_to {fielddate2}=((new DateCheck()).isEqualTo({fielddate1},{fielddate2}))
[condition][]it is not true that_checkTagValue pon {field} ver {field} ccna {field} icsc {field} section {section} tag {tag} equalsvalue {value} pos {pos}InRequestforResponse=(!((new SuplementOrderCheck()).checkTagValueInRequestforResponse((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag},{value},{pos})))
[condition][]the {fieldvalue} is present in NC table =((new ASOGTABLE()).fetchAbbreviationNCTable({fieldvalue}))
[condition][]the version {VER} is not one greater than the previous database version for the pon {PON} ccna {CCNA} and icsc {ICSC} with status {status}=((new SuplementOrderCheck()).verNotOneGreaterThanLatestDBVersion((xcb.xpath({VER})).stringValue(),(xcb.xpath({PON})).stringValue(),(xcb.xpath({CCNA})).stringValue(),{ICSC},{status}))
[condition][]it is not true that_the multiple field {field} is not numeric in any occurence=((new Occurence(xcb.getXmlInstance())).dataTypeCheckForMultipleOccuringTag({field}))
[condition][]the {field} is Required for {commaseperatedvalues}=((new Required()).requiredForValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]it is not true that_the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} and qty {QtyFieldValue} on the current order which has_decreasing QTY with respect to the previous order=(!((new SuplementOrderCheck()).qtyFieldCheck({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue},{QtyFieldValue})))
[condition][]it is not true that   new SuplementOrderCheck  checkResponseTagExistInRequest  =(!((new SuplementOrderCheck()).checkResponseTagExistInRequest()))
[condition][]the_field {field} is numeric with the last character as the {char}=((new DatatypeCheck()).numericWithLastCharacter((xcb.xpath({field})).stringValue(),{char}))
[condition][]any occurance{fieldwithxpath}fieldisPopulated=((new Occurence(xcb.getXmlInstance())).anyOccurenceOfFieldPopulated({fieldwithxpath}))
[condition][]the {sectn} has_the naickt{naiSectn} for the cancelled refnum{field} with value{value}=(virtualAnyNAICKTcheckForCancelledUREF({sectn},{naiSectn},{field},{value}))
[condition][]it is not true that_the_section {field} is_not_populated=(!((new Populated()).isNotPopulated((xcb.xpath({field})).stringValue())))
[condition][]the {pos} and {pos} position_of the {field} is greater than {pos} and {pos} position=((new Position()).twoPositionValueofTagIsGreaterThanTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]anyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues {var0} {var1} {var2} {var3} {var4} =((new Occurence(xcb.getXmlInstance())).anyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues({var0},{var1},{var2},{var3},{var4}))
[condition][]the {pos} to {pos} of the {field1} is_equal_to {pos} to {pos} of the {field2}=((new Position()).twoPositionRangeValueofTagEqualToValueOfAnotherTwoPosition({pos},{pos},{field1},{pos},{pos},{field2}))
[condition][]the {field} has_specified {segmentNumber} field not_equal_to alpha with virgule or period as delimiter=((new DatatypeCheck()).virguleandPeriodSegmentNotEqualToAlpha((xcb.xpath({field})).stringValue(),{segmentNumber}))
[condition][]it is not true that_the range of the {field} is AA to ZZ=(!((new RangeOfValues()).rangeCheckAA_ZZ((xcb.xpath({field})).stringValue())))
[condition][]the{section}{field} is not numerics with {errorcode}=((new Occurence(xcb.getXmlInstance())).VirtualResponseDataTypeNumericCheck({section},{field},{errorcode}))
[condition][]it is not true that_the {field} contains atleast one non space character in the range {start} to {end}=(!((new SpaceCheck()).checkAtleastOneNonSpaceInRange((xcb.xpath({field})).stringValue(),{start},{end})))
[condition][]it is not true that_noconfirmationOrderCheckNew pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}dedicate_recieve_customer{drc}=(!((new SuplementOrderCheck()).noConfirmationOrderCheckNew((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{description},{drc})))
[condition][]getLatestValidVersionInDataBaseWithStatus {var0} {var1} {var2} =((new SuplementOrderCheck()).getLatestValidVersionInDataBaseWithStatus({var0},{var1},{var2}))
[condition][]it is not true that_the {field} has_both uppercase and lowercase characters=(!((new CapitalLetterCheck()).isUpperAndLowerCase((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_noconfirmationOrderCheck pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=(!((new SuplementOrderCheck()).noConfirmationOrderCheck((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{description})))
[condition][]it is not true that_the {field} has_all uppercase characters for comma seperated values=(!((new CapitalLetterCheck()).isAllUpperCaseForCSV((xcb.xpath({field})).stringValue())))
[condition][]the {field} has_segment with specified {segnum} of the specified {length} to support virgule or period=((new LengthCheck()).virguleandPeriodSegmentNumberLengthEqualTo((xcb.xpath({field})).stringValue(),{segnum},{length}))
[condition][]occurenceOfFieldIsGreaterThanSpecifiedNumberWithGivenValue {var0} {var1} {var2} =((new Occurence(xcb.getXmlInstance())).occurenceOfFieldIsGreaterThanSpecifiedNumberWithGivenValue({var0},{var1},{var2}))
[condition][]the table {tablename} does not exists in the data base=((new ASOGTABLE()).checkNonExistenceOfTable({tablename}))
[condition][]it is not true that_duplicate order pon {pon} ver {ver} ccna {ccna} icsc {icsc} exists in DB=(!((new SuplementOrderCheck()).duplicateOrderCheck((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc})))
[condition][]it is not true that_valueOfFieldIsOneGreaterThanOccurenceOfAnotherField {var0} {var1} =((new Occurence(xcb.getXmlInstance())).valueOfFieldIsOneGreaterThanOccurenceOfAnotherField({var0},{var1}))
[condition][]it is not true that_the {field} is Required for {commaseperatedvalues}=(!((new Required()).requiredForValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]routing matrix value check when first column is ALL{section}{subsect}{field}=(virtualRoutingMatrixCheck2({section},{subsect},{field}))
[condition][]the {field} has_consecutive uppercase characters and should not be followed by space=((new CapitalLetterCheck()).consecUpperCaseWithNoSpaceAfter((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} contains {num} of consecutive spaces after Alpha Characters=(!((new CapitalLetterCheck()).containsConsecutiveSpacesAfterAlphaCharacters((xcb.xpath({field})).stringValue(),{num})))
[condition][]atleast one occurence of{section} is populated=(virtualsaliAtleastOneOccurenceSectionPopulated1({section}))
[condition][]the_field {field1} is greater than field {field2}=((new Equals()).field1IsGreaterThanField2({field1},{field2}))
[condition][]it is not true that_the {pos} and {pos} of {field} is_not_equal_to_values {CommaSeparatedValues}=(!((new Position()).twoPositionValueofTagNotEqualToValues({pos},{pos},(xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]the {field} position {pos} and {pos} is greater than or equal to {pos} and {pos}=((new Contains()).checkPositionalValuesGreaterThanOrEqualTo((xcb.xpath({field})).stringValue(),{pos},{pos},{pos},{pos}))
[condition][]it is not true that_the {field} has_telephone number format as {tnformat}=(!((new TNFormat()).tnFormatIs((xcb.xpath({field})).stringValue(),{tnformat})))
[condition][]the position_ {pos} of {field} is_not_equal_to {value}=((new Position()).positionOftagValueNotEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value}))
[condition][]the {fielddate1} is less than {fielddate2}=((new DateCheck()).isLessThan({fielddate1},{fielddate2}))
[condition][]the_field {fieldname} of {parentname} with value {fieldvalue} differs from previous version tag value for the pon {PON} version {VER} ccna {CCNA} and icsc{ICSC}=((new SuplementOrderCheck()).tagValueDiffersInPreviousVersion({fieldname},{parentname},{fieldvalue},(xcb.xpath({PON})).stringValue(),(xcb.xpath({VER})).stringValue(),(xcb.xpath({CCNA})).stringValue(),{ICSC}))
[condition][]it is not true that_the {field} is Numeric with Special Characters Set {setofspecialcharacters}=(!((new DatatypeCheck()).checkNumericSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters})))
[condition][]the maximum length of {field} is {value}=((new LengthCheck()).checkMaximumlength((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is_equal_to {pos} and {pos} position=(!((new Position()).twoPositionValueofTagEqualToValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]it is not true that_the interval between {fielddate1} and {fielddate2} is_not_equal_to {days}=(!((new DateCheck()).intervalBetweenTwoDateIsNotEqualtoDays({fielddate1},{fielddate2},{days})))
[condition][]the no of occurances of {fieldxpath} pair have different {fieldxpath} values=((new Occurence(xcb.getXmlInstance())).noOfOccurancesOfLactIOPairMustHaveDiffAliValue({fieldxpath},{fieldxpath}))
[condition][]the {field} has_date format as {format}=((new DateFormatCheck()).dateCheck((xcb.xpath({field})).stringValue(),{format}))
[condition][]the occurance of {fieldwithxpath} is_equal_to {number}=((new Occurence(xcb.getXmlInstance())).noOfOccurenceEqualTo({fieldwithxpath},{number}))
[condition][]the {field} has_specified segment {segnum} which contains alpha numeric characters with space=((new DatatypeCheck()).segmentEqualToAlphaNumericWithSpace((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]the pos1{pos1} to pos2{pos2} of the_field{fieldvalue} not in range {startvalue} to {endvalue}=((new RangeOfValues()).checkPos1ToPos2ValueNotInRange({pos1},{pos2},{fieldvalue},{startvalue},{endvalue}))
[condition][]it is not true that_positionOfAnyFieldNotEqualToCharacter {var0} {var1} {var2} =((new Occurence(xcb.getXmlInstance())).positionOfAnyFieldNotEqualToCharacter({var0},{var1},{var2}))
[condition][]the pon {field} ver {field} section {section} tag {tag} is populated in Request against Response=((new SuplementOrderCheck()).checkResponseTagExistInRequest((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag}))
[condition][]the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} and the UNI_MAPPING section which had the_field {FieldName} of values {commaseparatedvalues} and with all its elements of the previous order is_not_equal_to none of the UNI_MAPPING section with all its elements in current order=((new SuplementOrderCheck()).checkActiveUrefDoesNotExists({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue},{FieldName},{commaseparatedvalues}))
[condition][]the_field value {field} matches the pattern {pattern}=((new SpecialFormat()).isPatternMatches((xcb.xpath({field})).stringValue(),{pattern}))
[condition][]it is not true that_the_field value {field} matches the pattern {pattern}=(!((new SpecialFormat()).isPatternMatches((xcb.xpath({field})).stringValue(),{pattern})))
[condition][]it is not true that_the {field} has_specified segment {segnum} which contains alpha numeric characters with space=(!((new DatatypeCheck()).segmentEqualToAlphaNumericWithSpace((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]it is not true that_getRootXpath=((new Occurence(xcb.getXmlInstance())).getRootXpath())
[condition][]it is not true that_the pos1{pos1} to pos2{pos2} of the_field{fieldvalue} not in range {startvalue} to {endvalue}=(!((new RangeOfValues()).checkPos1ToPos2ValueNotInRange({pos1},{pos2},{fieldvalue},{startvalue},{endvalue})))
[condition][]it is not true that_the {field} having last {N} characters {chars} are preced by numeric=(!((new Equals()).lastNcharsprecededbynumeric((xcb.xpath({field})).stringValue(),{N},{chars})))
[condition][]it is not true that_virtualoccurenceofuactNCI {vector} {list} {ncivalue} {errorcode} =(!(virtualoccurenceofuactNCI({vector},{list},{ncivalue},{errorcode})))
[condition][]any occurence of {section}{field} is_not_populated with {errorcode}=((new Occurence(xcb.getXmlInstance())).VirtualAnyOccurenceIsNotPopulated({section},{field},{errorcode}))
[condition][]it is not true that_virtualoccurenceofSvlanMppingfortwoocc {Vector} {errorcode} =(!(virtualoccurenceofSvlanMppingfortwoocc({Vector},{errorcode})))
[condition][]it is not true that_noOfOccurence {var0} =((new Occurence(xcb.getXmlInstance())).noOfOccurence({var0}))
[condition][]the {field} has_the segment with specified {segnum} whose length is greater than specified {length} to support virgule or period=((new LengthCheck()).virguleandPeriodSegmentNumberLengthGreaterThan((xcb.xpath({field})).stringValue(),{segnum},{length}))
[condition][]it is not true that_any Occurnce of {fieldwithxpath} is_equal_to {character} in {pos}positon=((new Occurence(xcb.getXmlInstance())).positionOfAnyFieldEqualToCharacter({fieldwithxpath},{character},{pos}))
[condition][]it is not true that_Request PON{pon} VER{ver} CCNA{ccna} ICSC{icsc} exists in DB=(!((new SuplementOrderCheck()).checkRequestExistsInDatabase((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc})))
[condition][]it is not true that_routing matrix value check{section}{subsect}{field}=(!(virtualRoutingMatrixCheck({section},{subsect},{field})))
[condition][]virtualoccurenceofVACTandUACT3CEVLAN {var0} {var1} =(virtualoccurenceofVACTandUACT3CEVLAN({var0},{var1}))
[condition][]the_section{section} parent{parent} tag {tag} does not have value{value} in any occurence=(virtualNoneOccurenceEqualsValue({section},{parent},{tag},{value}))
[condition][]it is not true that_the_field {field} populated with segment {segno} with optional character {character} does not contain {startLength} to {endLength} Alpha Numerics=(!((new LengthCheck()).checkSegmentNotPopulatedInLengthWithOptionalCharacter((xcb.xpath({field})).stringValue(),{segno},{character},{startLength},{endLength})))
[condition][]it is not true that_any segment of the {fieldvalue} delimeted by space does not equal {commaseparatedvalues}=(!((new LengthCheck()).segmentsNotEquals({fieldvalue},{commaseparatedvalues})))
[condition][]the {field} has_ampersand which is not preceeded and followed by space=((new SpaceCheck()).isAmpersandNotPrecFollSpace((xcb.xpath({field})).stringValue()))
[condition][]setICSCNCNCICompatibilityLicense {var0} =((new SvcType()).setICSCNCNCICompatibilityLicense({var0}))
[condition][]it is not true that_isCurrentDateLessThanOrNotEqualToDesiredDueDate {var0} =(!((new DateCheck()).isCurrentDateLessThanOrNotEqualToDesiredDueDate({var0})))
[condition][]allOccurenceOfFieldEqualToValue {var0} {var1} =((new Occurence(xcb.getXmlInstance())).allOccurenceOfFieldEqualToValue({var0},{var1}))
[condition][]checkResponse_IcscTagExistInRequestIcsc {var0} {var1} {var2} {var3} =((new SuplementOrderCheck()).checkResponse_IcscTagExistInRequestIcsc({var0},{var1},{var2},{var3}))
[condition][]if {pos1} and {pos2} not in foramt {chhp} for {fdt}=((new DateFormatCheck()).time_format_chkforFDT({pos1},{pos2},{chhp},{fdt}))
[condition][]the {field} contains numeric characters=((new Contains()).containsNumeric((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} from positions {pos1} to {pos2} is populated or not spaces=(!((new Populated()).rangeOfPositionIsPopulatedOrNotSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2})))
[condition][]virtualoccurenceofVACTandUACT {section} {errorcode} =(virtualoccurenceofVACTandUACT({section},{errorcode}))
[condition][]the {field} contains embedded space=((new SpaceCheck()).containsEmbeddedSpace((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} equals {value}=(!((new Equals()).isEquals((xcb.xpath({field})).stringValue(),{value})))
[condition][]the {field} is AlphaNumeric with only space as special character=((new DatatypeCheck()).checkAlphaNumericWithSpaceAsSpecialCharacter((xcb.xpath({field})).stringValue()))
[condition][]checkAlphaNumericWithASingleSpecialCharacter {var0} {var1} =((new DatatypeCheck()).checkAlphaNumericWithASingleSpecialCharacter({var0},{var1}))
[condition][]the value of {field1withxpath} is_equal_to number of occurance of {field2withxpath}=((new Occurence(xcb.getXmlInstance())).tagValueOfOneFieldEqualToNoOfOccurenceOfAnotherField({field1withxpath},{field2withxpath}))
[condition][]it is not true that_the {field} is AlphaNumeric with Special Characters=(!((new DatatypeCheck()).checkAlphaNumericSP((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_checkCapsInField2ForPosInField1 {var0} {var1} {var2} =(!((new CapitalLetterCheck()).checkCapsInField2ForPosInField1({var0},{var1},{var2})))
[condition][]it is not true that_The {field} contains whitespaces or numbers in range or zeros from second position_to end=(!((new Position()).charAtPositionCheck((xcb.xpath({field})).stringValue())))
[condition][]virtualoccurenceofVACTandUACT3 {section} {errorcode} =(virtualoccurenceofVACTandUACT3({section},{errorcode}))
[condition][]it is not true that_confirmationOrderCheckDes pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=(!((new SuplementOrderCheck()).confirmationOrderCheckDes((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{description})))
[condition][]setNCILicense {var0} =((new SvcType()).setNCILicense({var0}))
[condition][]it is not true that_the {field} contains numeric values followed by lowercase Alpha Characters=(!((new CapitalLetterCheck()).fieldContainsNumericValuesFollowedByLowercaseAlphaCharacters((xcb.xpath({field})).stringValue())))
[condition][]checkResponsePonDoesNotExistInRequest {var0} {var1} {var2} =((new SuplementOrderCheck()).checkResponsePonDoesNotExistInRequest({var0},{var1},{var2}))
[condition][]the last character Of {field} is {value}=((new Equals()).lastCharacterOfField((xcb.xpath({field})).stringValue(),{value}))
[condition][]allLowerCase {var0} =((new CapitalLetterCheck()).allLowerCase({var0}))
[condition][]the {field} is in the range A1 to Z99=((new RangeOfValues()).rangeCheckA1_Z99((xcb.xpath({field})).stringValue()))
[condition][]the CCNA has_license for NCI Table=((new SvcType()).getNCILicense())
[condition][]cktActCheckWithPrevVer {var0} {var1} {var2} {var3} {var4} {var5} {var6} =((new SuplementOrderCheck()).cktActCheckWithPrevVer({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]it is not true that_the version is {VER} not_equal_to the latest database version for the pon {PON} ccna {CCNA} and icsc{ICSC} with the status {STATUS}=(!((new SuplementOrderCheck()).verNotEqualToLatestDBVersion((xcb.xpath({VER})).stringValue(),(xcb.xpath({PON})).stringValue(),(xcb.xpath({CCNA})).stringValue(),{ICSC},{STATUS})))
[condition][]it is not true that_the {pos} position_of {field} is in range {startvalue} and {endvalue}=(!((new Populated()).isPostionOfFieldPopulatedInRange({pos},(xcb.xpath({field})).stringValue(),{startvalue},{endvalue})))
[condition][]getXPathWithPosition {var0} {var1} =((new XpathLookup()).getXPathWithPosition({var0},{var1}))
[condition][]it is not true that_checkForLowerCaseLettersAfterNumbers {var0} =(!((new CapitalLetterCheck()).checkForLowerCaseLettersAfterNumbers({var0})))
[condition][]the {field} has_no values{commaseperatedvalues} in the segment{segnum} to support virgule or period as delimiter=((new Equals()).virguleandPeriodSegmentValueNotEqualToValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues},{segnum}))
[condition][]it is not true that_the CCNA has_license for NCNCICOMPATIBILITY Table=(!((new SvcType()).getNCNCICompatibilityLicense()))
[condition][]the position {pos} of {field} is_not_equal_to_values {commaseperatedvalues}=((new Position()).positionOftagValueNotEqualToValues({pos},(xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]the {field} is compared with the specified positions {pos1} to {pos2} with values {value1} or {value2}=((new Position()).compareCharAtAnyPositionWithAnyValue((xcb.xpath({field})).stringValue(),{pos1},{pos2},{value1},{value2}))
[condition][]it is not true that_any occurence of{fieldwithxpath} is_not_populated=((new Occurence(xcb.getXmlInstance())).anyOccurenceOfFieldNotPopulated({fieldwithxpath}))
[condition][]the {field} is not Required=((new Required()).isNotRequired((xcb.xpath({field})).stringValue()))
[condition][]number of occurences{fieldwithxpath} equals{value}=((new Occurence(xcb.getXmlInstance())).noOfOccurenceEqualsValue({fieldwithxpath},{value}))
[condition][]the {field} contains invalid values or with valid values {commaseparatedvalues} without spaces between them or repeated=((new Contains()).containsInvalidOrValidWithoutSpaceOrRepeated((xcb.xpath({field})).stringValue(),{commaseparatedvalues}))
[condition][]it is not true that_the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} and the UNI_MAPPING section which had the_field {FieldName} of values {commaseparatedvalues} and with all its elements of the previous order is_not_equal_to none of the UNI_MAPPING section with all its elements in current order=(!((new SuplementOrderCheck()).checkActiveUrefDoesNotExists({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue},{FieldName},{commaseparatedvalues})))
[condition][]it is not true that_vitualsvlanthirdOccurenceProhibit {vector} {errorcode} =((new Occurence(xcb.getXmlInstance())).vitualsvlanthirdOccurenceProhibit({vector},{errorcode}))
[condition][]it is not true that_the {field} has_the specified segment with number {segnum} whose length is in range {min} to {max} to support virgule or period as delimiter=(!((new LengthCheck()).virguleandPeriodSegmentNumberLengthInRange((xcb.xpath({field})).stringValue(),{segnum},{min},{max})))
[condition][]it is not true that_atleast one occurence of{section}{subsectn} is populated=(!(virtualsaliAtleastOneOccurenceSectionPopulated({section},{subsectn})))
[condition][]it is not true that_the {field} has_specified {segmentNumber} field not_equal_to alpha with virgule or period as delimiter=(!((new DatatypeCheck()).virguleandPeriodSegmentNotEqualToAlpha((xcb.xpath({field})).stringValue(),{segmentNumber})))
[condition][]set the activity of to {var0}=((new ReqTypeAct()).setActivity({var0}))
[condition][]the{section}{subsect}{field}not populated and assosiated tag{tag}is populated and corresponding section tag{corrstag}equals to {values}=(virtualLrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue({section},{subsect},{field},{tag},{corrstag},{values}))
[condition][]it is not true that_the_section {section} {field} is populated in any occurence with {errorcode}=(!(virtualFieldIsPopulated({section},{field},{errorcode})))
[condition][]the {pos} and {pos} position_of the {field} is lesser than or equal to {pos} and {pos} position=((new Position()).twoPositionValueofTagIsLessThanOrEqualToTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]virtualoccOfVPNIDnSVLANSTARTwithinsameUNIMAPPING {section} {errorcode} =(virtualoccOfVPNIDnSVLANSTARTwithinsameUNIMAPPING({section},{errorcode}))
[condition][]lrefTagCheck {var0} {var1} {var2} {var3} =((new SuplementOrderCheck()).lrefTagCheck({var0},{var1},{var2},{var3}))
[condition][]the_field {fieldname} of {parentname} with value {fieldvalue} differs from previous version tag value for the pon {PON} version {VER} ccna {CCNA} and icsc{ICSC} and compare with {val1} {val2}=((new SuplementOrderCheck()).CHKVAR_Access({fieldname},{parentname},{fieldvalue},(xcb.xpath({PON})).stringValue(),(xcb.xpath({VER})).stringValue(),(xcb.xpath({CCNA})).stringValue(),{ICSC},{val1},{val2}))
[condition][]it is not true that_the {field} has_segment with specified {segnum} of the specified {length}=(!((new LengthCheck()).segmentNumberLengthEqualTo((xcb.xpath({field})).stringValue(),{segnum},{length})))
[condition][]virtualOccurenceofEIandUACTinUNIMAPPING {section} {errorcode} =(virtualOccurenceofEIandUACTinUNIMAPPING({section},{errorcode}))
[condition][]it is not true that_the {field} is in the range A1 to Z99=(!((new RangeOfValues()).rangeCheckA1_Z99((xcb.xpath({field})).stringValue())))
[condition][]the segment {segnum} length of field {fieldvalue} is in the range {min} and {max}=((new LengthCheck()).segmentNumberLengthInRange({segnum},{fieldvalue},{min},{max}))
[condition][]the {field} is_not_populated=((new Populated()).isNotPopulated((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the ccna{ccna} and icsc{icsc} combination exists=(!((new SuplementOrderCheck()).checkCcnaIcscCombination((xcb.xpath({ccna})).stringValue(),{icsc})))
[condition][]the {fieldvalue} is present in NCI table =((new ASOGTABLE()).fetchAbbreviationNCITable({fieldvalue}))
[condition][]it is not true that_the {field} has_specified {segmentNumber} not_equal_to space=(!((new DatatypeCheck()).segmentNotEqualToSpace((xcb.xpath({field})).stringValue(),{segmentNumber})))
[condition][]checkValidatedAndTransmittedRequestInDatabase pon {field} ver {field} ccna {field} icsc {field} =((new SuplementOrderCheck()).checkValidatedAndTransmittedRequestInDatabase((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {pos} to {pos} of the {field1} is_equal_to {pos} to {pos} of the {field2}=(!((new Position()).twoPositionRangeValueofTagEqualToValueOfAnotherTwoPosition({pos},{pos},{field1},{pos},{pos},{field2})))
[condition][]it is not true that_the {field} has_specified segment {segnum} which has_the specified alpha {specAlpha}=(!((new DatatypeCheck()).segmentNotEqualToSpecifiedAlpha((xcb.xpath({field})).stringValue(),{segnum},{specAlpha})))
[condition][]the {pos} position_of {field} is_equal_to {value}=((new Position()).positionOftagValueEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value}))
[condition][]timeRange {var0} {var1} {var2} =((new TimeFormatCheck()).timeRange({var0},{var1},{var2}))
[condition][]it is not true that_alloccuranceof field{path} not_equals values{commaseperatedvalues}=((new Occurence(xcb.getXmlInstance())).allOccurenceOfFieldNotEqualsValues({path},{commaseperatedvalues}))
[condition][]it is not true that_the last character Of {field} is {value}=(!((new Equals()).lastCharacterOfField((xcb.xpath({field})).stringValue(),{value})))
[condition][]the position {pos1} and {pos2} of {field} is between {startrange} and {endrange}=((new RangeOfValues()).twoFieldPositionInRange({pos1},{pos2},(xcb.xpath({field})).stringValue(),{startrange},{endrange}))
[condition][]it is not true that_the {field} is Numeric=(!((new DatatypeCheck()).checkNumeric((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_comparePrevVerAndCurrVerFieldValue {var0} {var1} {var2} {var3} {var4} {var5} {var6} {var7} {var8} {var9} {var10} =(!((new SuplementOrderCheck()).comparePrevVerAndCurrVerFieldValue({var0},{var1},{var2},{var3},{var4},{var5},{var6},{var7},{var8},{var9},{var10})))
[condition][]it is not true that_the {field} contains {num} of consecutive lowercase Alpha Characters=(!((new CapitalLetterCheck()).containsConsecutiveLowercaseAlphaCharacters((xcb.xpath({field})).stringValue(),{num})))
[condition][]it is not true that_the {fieldwithxpath} is prohibited=(!((new Prohibited()).isProhibited({fieldwithxpath})))
[condition][]routing matrix value check{section}{subsect}{field}=(virtualRoutingMatrixCheck({section},{subsect},{field}))
[condition][]it is not true that_the_length_of {field} is_equal_to {value}=(!((new LengthCheck()).checkLength((xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_segmentValueEquals {var0} {var1} {var2} =(!((new Equals()).segmentValueEquals({var0},{var1},{var2})))
[condition][]anyARIPrilocAndPrilocSpotCheck {var0} {var1} {var2} =((new Occurence(xcb.getXmlInstance())).anyARIPrilocAndPrilocSpotCheck({var0},{var1},{var2}))
[condition][]Is the {field} of the specified {segnum} according to the format {format}=((new DateFormatCheck()).isSpecifiedSegmentInValidFormat((xcb.xpath({field})).stringValue(),{segnum},{format}))
[condition][]the multiple field{field} has_length greater than{value} in any occurence=((new Occurence(xcb.getXmlInstance())).lengthCheckForMultipleOccuringTag({field},{value}))
[condition][]valueOfFieldIsOneGreaterThanOccurenceOfAnotherField {var0} {var1} =((new Occurence(xcb.getXmlInstance())).valueOfFieldIsOneGreaterThanOccurenceOfAnotherField({var0},{var1}))
[condition][]it is not true that_the {field} is Alpha=(!((new DatatypeCheck()).checkAlpha((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_routing matrix value check when any ALL is present{section}{subsect}{field}=(!(virtualRoutingMatrixCheck1({section},{subsect},{field})))
[condition][]it is not true that_positionOfStringInSpecifiedRange {var0} {var1} {var2} {var3} =(!((new RangeOfValues()).PositionOfStringInSpecifiedRange({var0},{var1},{var2},{var3})))
[condition][]the {field} from {pos1} to {pos2} of the segment{segnum} are not alpha characters to supportvirgule or period as delimiter=((new LengthCheck()).virguleandPeriodPosToPosOfSegmentAreNotAlpha((xcb.xpath({field})).stringValue(),{pos1},{pos2},{segnum}))
[condition][]the_field{field} with segment{segment} equals{value}=((new Position()).compareSpecifiedSegmentWithValue((xcb.xpath({field})).stringValue(),{segment},{value}))
[condition][]the {field} from positions {pos1} to {pos2} is_not_populated or spaces=((new Populated()).rangeOfPositionIsNotPopulatedOrSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2}))
[condition][]it is not true that_the {field} is compared with its position {pos1} to {pos2} with values {values}=(!((new Position()).compareCharAtAnyPositionWithAnyNumberOfValue((xcb.xpath({field})).stringValue(),{pos1},{pos2},{values})))
[condition][]it is not true that_setSvcNameUOM {var0} =(!((new SvcType()).setSvcNameUOM({var0})))
[condition][]it is not true that_the value of {field} not_equals the occurences of{section}=(!(virtualsaliValueOfFieldNotEqualsOccurenceOfOtherSection1({field},{section})))
[condition][]it is not true that_anyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues {var0} {var1} {var2} {var3} {var4} =((new Occurence(xcb.getXmlInstance())).anyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues({var0},{var1},{var2},{var3},{var4}))
[condition][]the_length_of {field} is between {min} and {max} values=((new LengthCheck()).checkMinMaxLength((xcb.xpath({field})).stringValue(),{min},{max}))
[condition][]it is not true that_the ASR Request order exists for the pon {PON} ccna {CCNA} and icsc {ICSC}=(!((new SuplementOrderCheck()).checkRequestPonExistsInDatabase((xcb.xpath({PON})).stringValue(),(xcb.xpath({CCNA})).stringValue(),{ICSC})))
[condition][]virtualoccurenceofVACTandUACT2 {section} {errorcode} =(virtualoccurenceofVACTandUACT2({section},{errorcode}))
[condition][]it is not true that_all tags of unimapping {section} in current and previous version check {sup} {pon} {ver} {ccna} {icsc} {uact} {values} {uref} with {code}=((new Occurence(xcb.getXmlInstance())).VirtualUnimappingTagsCheckWIthPreviousVer({section},{sup},(xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{uact},{values},{uref},{code}))
[condition][]it is not true that_the {field} with segment {segnum} is_not_populated=(!((new Populated()).segmentIsNotPopulated((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]any one of the segment that may be delimeted by the char {delimchar} of the {field} does not contain {Alpha} Alpha character followed by maximum number {num} of numeric characters=((new LengthCheck()).segmentDoesNotContainsAlphaCountFollowedByNumericCount({delimchar},(xcb.xpath({field})).stringValue(),{Alpha},{num}))
[condition][]any of the {fieldwithxpath} has {character}=((new Occurence(xcb.getXmlInstance())).anyCharacterOfFieldIs({fieldwithxpath},{character}))
[condition][]Spec_Lrefchk{Lref} Lref{lref} spec{spec} and occurance{occurance} with errorCode {errorcode}=(virtualSpecLrefchk({Lref},{lref},{spec},{occurance},{errorcode}))
[condition][]noConfirmationOrderCheck {var0} {var1} {var2} {var3} =((new SuplementOrderCheck()).noConfirmationOrderCheck({var0},{var1},{var2},{var3}))
[condition][]it is not true that_the {field} has_specified {segmentNumber} not_equal_to numeric=(!((new DatatypeCheck()).segmentNotEqualToNumeric((xcb.xpath({field})).stringValue(),{segmentNumber})))
[condition][]it is not true that_setIcscCLLILicense {var0} =(!((new SvcType()).setIcscCLLILicense({var0})))
[condition][]the {field} is Numeric without Special Characters Set {setofspecialcharacters}=((new DatatypeCheck()).checkNumericWithOutSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters}))
[condition][]it is not true that_no of occurences of tag {fieldxpath1} with {field1} and {fieldxpath2} with {field2} are equal=((new Occurence(xcb.getXmlInstance())).noOfOccurencesOfBothTagAreEqualForSpecifiedPairValue({fieldxpath1},{field1},{fieldxpath2},{field2}))
[condition][]the {field} contains alpha characters=((new Contains()).containsAlpha((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_noOfCharactersinTag {var0} {var1} {var2} =(!((new Contains()).NoOfCharactersinTag({var0},{var1},{var2})))
[condition][]the {field} has_space as a special character=((new SpaceCheck()).spaceAsSpecialCharacter((xcb.xpath({field})).stringValue()))
[condition][]the {section}{field} is_not_populated in all occurence=((new Occurence(xcb.getXmlInstance())).VirtualNoOccurenceIsPopulated({section},{field}))
[condition][]the CCNA has_license for NC Table=((new SvcType()).getNCLicense())
[condition][]it is not true that_the_field differs from previous version tag value for the pon {PON} version {VER} icsc{ICSC} and ccna{CCNA} {fieldname} of {parentname} at pos{POS} with field {fieldvalue}=(!((new SuplementOrderCheck()).tagValueDiffersInPreviousVersionatspecpos((xcb.xpath({PON})).stringValue(),(xcb.xpath({VER})).stringValue(),{ICSC},(xcb.xpath({CCNA})).stringValue(),{fieldname},{parentname},{POS},{fieldvalue})))
[condition][]confirmationOrderCheck pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=((new SuplementOrderCheck()).confirmationOrderCheck((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{description}))
[condition][]it is not true that_the interval between {fielddate1} and {fielddate2} is greater than {days}=(!((new DateCheck()).intervalBetweenTwoDateIsGreaterThanDays({fielddate1},{fielddate2},{days})))
[condition][]any_occurance_of_the {field1withxpath} is_not_equal_to {value}=((new Occurence(xcb.getXmlInstance())).anyOccurenceNotEqualToValue({field1withxpath},{value}))
[condition][]it is not true that_getvalue {var0} =((new Occurence(xcb.getXmlInstance())).getvalue({var0}))
[condition][]it is not true that_Is the {fieldDate1} not_equal_to {comparisonDate} in the format {CCYYMMDD}=(!((new DateFormatCheck()).isFieldNotEqualToComparisonDateInspecifiedFormat({fieldDate1},{comparisonDate},{CCYYMMDD})))
[condition][]the {field} has_all lowercase characters=((new CapitalLetterCheck()).isAllLowerCase((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_all occurences of {section} of field {field} equals the value{value} with errorcode {errorcode}=(!(virtualAllOccurenceOfFieldEqualsValue({section},{field},{value},{errorcode})))
[condition][]it is not true that_the interval between {fielddate1} and {fielddate2} is less than or equal to {days}=(!((new DateCheck()).intervalBetweenTwoDateIsLessThanOrEqualtoDays({fielddate1},{fielddate2},{days})))
[condition][]the difference between {fielddate1} and {fielddate2} is_not_equal_to one year=((new DateCheck()).isRangeNotEqualToOneYear({fielddate1},{fielddate2}))
[condition][]it is not true that_the {fielddate1} is less than or equal to {fielddate2}=(!((new DateCheck()).isLessThanOrEqualTo({fielddate1},{fielddate2})))
[condition][]it is not true that_the {field} contains {num} of consecutive uppercase Alpha Characters=(!((new CapitalLetterCheck()).containsConsecutiveUppercaseAlphaCharacters((xcb.xpath({field})).stringValue(),{num})))
[condition][]virtualoccOfF1nF2andVAL1nVAL2withinsameUNIMAPPING {section} {errorcode} {field1} {F1values} {field2} {F2values} {field3} =(virtualoccOfF1nF2andVAL1nVAL2withinsameUNIMAPPING({section},{errorcode},{field1},{F1values},{field2},{F2values},{field3}))
[condition][]the {field} has_words seperated by a comma=((new DatatypeCheck()).commaPresenceForMoreThanOneWord((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_any one of the segment that may be delimeted by the char {delimchar} of the {field} does not contain {Alpha} Alpha character followed by maximum number {num} of numeric characters=(!((new LengthCheck()).segmentDoesNotContainsAlphaCountFollowedByNumericCount({delimchar},(xcb.xpath({field})).stringValue(),{Alpha},{num})))
[condition][]it is not true that_the {field} contains {CommaSeparatedValues}=(!((new Contains()).contains((xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]it is not true that_the {fielddate1} is todays date=(!((new DateCheck()).isToday({fielddate1})))
[condition][]it is not true that_any_occurance_of_the {field1withxpath} is_not_equal_to {value}=((new Occurence(xcb.getXmlInstance())).anyOccurenceNotEqualToValue({field1withxpath},{value}))
[condition][]the{section}{field} lengths not_equals{value} with code {code}=(virtualResponseLengthCheck({section},{field},{value},{code}))
[condition][]segmentEqualToAlphaNumericWithSPChar {var0} {var1} {var2} =((new DatatypeCheck()).segmentEqualToAlphaNumericWithSPChar({var0},{var1},{var2}))
[condition][]segmentValueEquals {var0} {var1} {var2} =((new Equals()).segmentValueEquals({var0},{var1},{var2}))
[condition][]the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} on the current order and does not have same {CCNAICSC} on the previous order=((new SuplementOrderCheck()).checkCcnaIcscActWithPreviousVersion({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue},{CCNAICSC}))
[condition][]the_section{section} with the_field {field} is not consecutively assigned from value{value} with errorcode {errorcode}=(virtualFieldIsNotConsecutivelyAssignedAcrossOccurrences({section},{field},{value},{errorcode}))
[consequence][]setCLLILicense {var0} =((new SvcType()).setCLLILicense({var0}))
[condition][]it is not true that_the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} on the current order and matching with the previous order which has_a status CANCEL=(!((new SuplementOrderCheck()).supFieldCheck({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue})))
[condition][]it is not true that_noconfirmationOrderCheckDes pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=(!((new SuplementOrderCheck()).noConfirmationOrderCheckDes((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{description})))
[condition][]it is not true that_the_section {section} with field {field} is not unique accross all occurences then errorcode {errorcode}=(!(virtualIsUnique({section},{field},{errorcode})))
[condition][]it is not true that_the {section} for lref when uact is_not_equal_to CKT with {errorcode}=(!(virtuallrefProhibitedWhenUactNotEqualsCNK({section},{errorcode})))
[condition][]it is not true that_the order is a resend order=(!((new SuplementOrderCheck()).resendOrderCheck()))
[condition][]isCurrentDateLessThanOrNotEqualToDesiredDueDate {var0} =((new DateCheck()).isCurrentDateLessThanOrNotEqualToDesiredDueDate({var0}))
[condition][]it is not true that_the {pos} position_of {field} is_not_equal_to_values {commaseperatedvalues}=(!(virtualPositionOftagValueNotEqualToValues({pos},(xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]it is not true that_the {field} has_three consecutive uppercase alphabets=(!((new CapitalLetterCheck()).threeConsecutiveUpperCaseAlpha((xcb.xpath({field})).stringValue())))
[condition][]virtualRefnumEqulasSegment {var0} {var1} =(virtualRefnumEqulasSegment({var0},{var1}))
[condition][]the {pos} position_of {field} is in range {startvalue} and {endvalue}=((new Populated()).isPostionOfFieldPopulatedInRange({pos},(xcb.xpath({field})).stringValue(),{startvalue},{endvalue}))
[condition][]it is not true that_virtualoccOfVPNIDnSVLANSTARTnASNwithinsameUNIMAPPING {section} {errorcode} =(!(virtualoccOfVPNIDnSVLANSTARTnASNwithinsameUNIMAPPING({section},{errorcode})))
[condition][]the_field differs from previous version tag value for the pon {PON} version {VER} icsc{ICSC} and ccna{CCNA} {fieldname} of {parentname} at pos{POS} with field {fieldvalue}=((new SuplementOrderCheck()).tagValueDiffersInPreviousVersionatspecpos((xcb.xpath({PON})).stringValue(),(xcb.xpath({VER})).stringValue(),{ICSC},(xcb.xpath({CCNA})).stringValue(),{fieldname},{parentname},{POS},{fieldvalue}))
[condition][]it is not true that_confirmationOrderCheck {var0} {var1} {var2} {var3} =(!((new SuplementOrderCheck()).confirmationOrderCheck({var0},{var1},{var2},{var3})))
[condition][]it is not true that_from the {pos1} to {pos2} has {format} for the {field}=(!((new DateFormatCheck()).time_format_chk({pos1},{pos2},{format},(xcb.xpath({field})).stringValue())))
[condition][]it is not true that_segact of ARI{ari} {segact} and RING{ring} value check with errorcode {errorcode}=(!(virtualSegactValueCheck({ari},{segact},{ring},{errorcode})))
[condition][]it is not true that_the {field} contains alpha characters=(!((new Contains()).containsAlpha((xcb.xpath({field})).stringValue())))
[condition][]the {field} contains numeric values followed by lowercase Alpha Characters=((new CapitalLetterCheck()).fieldContainsNumericValuesFollowedByLowercaseAlphaCharacters((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_virtualoccOfVPNIDnSVLANSTARTwithinsameUNIMAPPING {section} {errorcode} =(!(virtualoccOfVPNIDnSVLANSTARTwithinsameUNIMAPPING({section},{errorcode})))
[condition][]it is not true that_the {field} is Prohibited for {commaseperatedvalues}=(!((new Prohibited()).prohibitedForValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]it is not true that_set the activity of to {var0}=(!((new ReqTypeAct()).setActivity({var0})))
[condition][]tagValue {var0} =((new Occurence(xcb.getXmlInstance())).tagValue({var0}))
[condition][]the sup {SupFieldValue} is populated with act {ActFieldValue} and pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} on the current order and does not have same ACT on the previous order=((new SuplementOrderCheck()).actFieldCheck({SupFieldValue},{ActFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue}))
[condition][]the {fielddate1} is todays date=((new DateCheck()).isToday({fielddate1}))
[condition][]the {field} doesnot have {N} number of segments=((new LengthCheck()).fieldDoesNothaveNumberOfSegments((xcb.xpath({field})).stringValue(),{N}))
[condition][]it is not true that_isValidDate1 {var0} =(!((new DateCheck()).isValidDate1({var0})))
[condition][]the pos {pos} to {pos} of segment {segnum} of the_field {field} does not_equal_to_values {commaseparatedvalues}=((new LengthCheck()).posToPosOfSegmentNotEquals({pos},{pos},{segnum},(xcb.xpath({field})).stringValue(),{commaseparatedvalues}))
[condition][]virtualoccurenceofuactNCIRuid {vector} {list} {ncivalue} {errorcode} =(virtualoccurenceofuactNCIRuid({vector},{list},{ncivalue},{errorcode}))
[condition][]it is not true that_the {field} has_all lowercase characters for comma seperated values=(!((new CapitalLetterCheck()).isAllLowerCaseForCSV((xcb.xpath({field})).stringValue())))
[condition][]eachCharacterPreceededOrFollowedByNumeric {var0} {var1} =((new Contains()).eachCharacterPreceededOrFollowedByNumeric({var0},{var1}))
[condition][]the {field} is less than {value}=((new Equals()).isLessThan((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {field} is numeric with trailing spaces=(!((new DatatypeCheck()).checkNumericWithTrailingSPacesOnly((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the CCNA has_license for ICSC Table=(!((new SvcType()).getICSCLicense()))
[condition][]the {field} has_format as {format}=((new SpecialFormat()).formatIs((xcb.xpath({field})).stringValue(),{format}))
[condition][]the{section}{subsect}{field} populated and assosiated tag{tag}is_not_populated or corresponding section tag{corrstag}not_equals to {values}=(virtualLrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues({section},{subsect},{field},{tag},{corrstag},{values}))
[condition][]the_section {section} with field {field} is not unique accross all occurences then errorcode {errorcode}=(virtualIsUnique({section},{field},{errorcode}))
[condition][]it is not true that_the {field} is_not_populated=(!((new Populated()).isNotPopulated((xcb.xpath({field})).stringValue())))
[condition][]the {fielddate1} is a working day=((new DateCheck()).isWorkingDay({fielddate1}))
[condition][]it is not true that_the {pos} position_of {field} is_not_equal_to {value}=(!(virtualPositionOftagValueNotEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_virtualIntegerToString {var0} =(!(virtualIntegerToString({var0})))
[condition][]setCLLILicense {var0} =((new SvcType()).setCLLILicense({var0}))
[condition][]the {field} is numeric with trailing spaces=((new DatatypeCheck()).checkNumericWithTrailingSPacesOnly((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the_field1 {field1} and field2 {field2} Combination is_Invalid for the Valid_field1 values {values} and combination {KVcmob}=(!(virtual_keyValueCombination({field1},{field2},{values},{KVcmob})))
[condition][]it is not true that_the_section EVC {section} with sub section {subsect} for the field {field} is not conecutively assigned starting with {value} then errorcode {errorcode}=(!(virtuallrefIsNotConecutivelyAssignedStratingWIthValue({section},{subsect},{field},{value},{errorcode})))
[condition][]it is not true that_the pos {pos} in any of the segment delimeted by the char {delimchar} of the {field} does not equal {commaseparatedvalues}=(!(virtualPosOfSegmentsDoesNotEquals({pos},{delimchar},(xcb.xpath({field})).stringValue(),{commaseparatedvalues})))
[condition][]it is not true that_virtualoccurenceofVACTandUACT2CEVLAN {var0} {var1} =(!(virtualoccurenceofVACTandUACT2CEVLAN({var0},{var1})))
[condition][]it is not true that_the {field} has_specified segment {segnum} which contains alpha numeric characters with virgule or period as delimiter=(!((new DatatypeCheck()).virguleandPeriodSegmentEqualToAlphaNumeric((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]the {pos} position_of {field1} is_equal_to {pos} position_of {field2}=((new Position()).positionOfOneFieldIsEqualToPositionOfAnother({pos},{field1},{pos},{field2}))
[condition][]section{section} tag{tag} not populated=(virtualNotPopulated({section},{tag}))
[condition][]it is not true that_the {field} has {N} number of segments=(!((new LengthCheck()).fieldHasNumberOfSegments((xcb.xpath({field})).stringValue(),{N})))
[condition][]it is not true that_setCLLILicense {var0} =(!((new SvcType()).setCLLILicense({var0})))
[condition][]it is not true that_the pon {field} ver {field} section {section} tag {tag} is populated in Request against Response=(!((new SuplementOrderCheck()).checkResponseTagExistInRequest((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag})))
[condition][]the each position_from {pos1} to {pos2} of {field} is_not_equal_to_values{commaseperatedvalues}=((new Position()).checkEachPositionsInRangeNotEqualToValues({pos1},{pos2},(xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]the {field} has_specified {segmentNumber} not_equal_to numeric with virgule or period as delimiter=((new DatatypeCheck()).virguleandPeriodSegmentNotEqualToNumeric((xcb.xpath({field})).stringValue(),{segmentNumber}))
[condition][]anyOccurenceOf{section}{tag} equals {commaseperatedvalues}=(virtualfieldEqualsValues({section},{tag},{commaseperatedvalues}))
[condition][]it is not true that_containsSpaceInSpecRange {var0} {var1} {var2} =(!((new Contains()).containsSpaceInSpecRange({var0},{var1},{var2})))
[condition][]the pos {pos} in any of the segment delimeted by the char {delimchar} of the {field} does not equal {commaseparatedvalues}=(virtualPosOfSegmentsDoesNotEquals({pos},{delimchar},(xcb.xpath({field})).stringValue(),{commaseparatedvalues}))
[condition][]it is not true that_the range of the {field} is A0 to Z9=(!((new RangeOfValues()).rangeCheckA0_Z9((xcb.xpath({field})).stringValue())))
[condition][]the_field value {field} do_not_matches the pattern {pattern}=((new SpecialFormat()).isPatternNotMatches((xcb.xpath({field})).stringValue(),{pattern}))
[condition][]the {field} contains trailing space character=((new SpaceCheck()).checktrailspaces((xcb.xpath({field})).stringValue()))
[condition][]it is not true that   new ReqTypeAct  getActivity  =(!((new ReqTypeAct()).getActivity()))
[condition][]the position_of Alpha is {pos} in {field}=((new DatatypeCheck()).checkPositionAlpha({pos},(xcb.xpath({field})).stringValue()))
[condition][]the {fielddate1} is a Holiday=((new DateCheck()).isInHolidayList({fielddate1}))
[condition][]any occurence of field{section}{field} is_not_populated and assosiated tag{tag} equals {values} and corresponding tag{tag} equals {values}=(virtualAnyOccurenceOfFieldNotPopulatedAndAssosiatedTagEqualsValuesAndCorrespondingTagEqualsValues({section},{field},{tag},{values},{tag},{values}))
[condition][]the {field} is AlphaNumeric with following Special Character set {setofspecialcharacters}=((new DatatypeCheck()).checkAlphaNumericSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters}))
[condition][]anyOccurenceSection{sect}WithTag1{tag1}NotpopulatedAndTag2{tag2}Populatedwith errorcode{errorcode}=(virtualanyOccurenceWithTag1NotpopulatedAndTag2Populated({sect},{tag1},{tag2},{errorcode}))
[condition][]it is not true that_the_field {fieldname} of {parentname} with value {fieldvalue} differs from previous version tag value for the pon {PON} version {VER} ccna {CCNA} and icsc{ICSC} and compare with {val1} {val2}=(!((new SuplementOrderCheck()).CHKVAR_Access({fieldname},{parentname},{fieldvalue},(xcb.xpath({PON})).stringValue(),(xcb.xpath({VER})).stringValue(),(xcb.xpath({CCNA})).stringValue(),{ICSC},{val1},{val2})))
[condition][]it is not true that_the value of {field1withxpath} is_equal_to number of occurance of {field2withxpath}=((new Occurence(xcb.getXmlInstance())).tagValueOfOneFieldEqualToNoOfOccurenceOfAnotherField({field1withxpath},{field2withxpath}))
[condition][]the CCNA has_license for ICSC Table=((new SvcType()).getICSCLicense())
[condition][]spaceOrCharacterOrNumberInRange01_99 {var0} {var1} {var2} {var3} {var4} =((new Position()).spaceOrCharacterOrNumberInRange01_99({var0},{var1},{var2},{var3},{var4}))
[condition][]characterFollowedBySpace {var0} {var1} =((new Contains()).characterFollowedBySpace({var0},{var1}))
[condition][]it is not true that_the each position_from {pos1} to {pos2} of {field} is not in between {startrange} and {endrange}=(!((new RangeOfValues()).checkPositionsInRangeNotPopulatedInRangeOfValues({pos1},{pos2},(xcb.xpath({field})).stringValue(),{startrange},{endrange})))
[condition][]it is not true that_AnyOccoffield1withsection{multiecoec} field1 {OECICSC}equals field2{field2} with values {value1} and {value2} with errorCode {errorcode}=(!(virtualAnyOccoffield1equalsvaluewherefield2notequalsvalue({multiecoec},{OECICSC},{field2},{value1},{value2},{errorcode})))
[condition][]the occurance of {fieldwithxpath} is less than {number}=((new Occurence(xcb.getXmlInstance())).noOfOccurenceLessThan({fieldwithxpath},{number}))
[condition][]anyOccurenceOfSaliTagEqualsValue {var0} {var1} {var2} {var3} {var4} =((new Occurence(xcb.getXmlInstance())).anyOccurenceOfSaliTagEqualsValue({var0},{var1},{var2},{var3},{var4}))
[condition][]it is not true that_any occurence of multiple {field} is populated=((new Occurence(xcb.getXmlInstance())).anyOccurenceOfMultipleFieldIsPopulated({field}))
[condition][]the {field} has_all uppercase characters=((new CapitalLetterCheck()).isAllUpperCase((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} from positions {pos1} to {pos2} is_not_populated and not spaces=(!((new Populated()).rangeOfPositionIsNotPopulatedAndNotSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2})))
[condition][]it is not true that_fieldPositionInRange {var0} {var1} {var2} {var3} =(!((new RangeOfValues()).fieldPositionInRange({var0},{var1},{var2},{var3})))
[condition][]virtualoccOfF1POPnF2NOTPOPwithinsameUNIMAPPING {section} {errorcode} {field1} {field2} {field3} =(virtualoccOfF1POPnF2NOTPOPwithinsameUNIMAPPING({section},{errorcode},{field1},{field2},{field3}))
[condition][]it is not true that_the {field} position {pos} and {pos} is greater than or equal to {pos} and {pos}=(!((new Contains()).checkPositionalValuesGreaterThanOrEqualTo((xcb.xpath({field})).stringValue(),{pos},{pos},{pos},{pos})))
[condition][] new SuplementOrderCheck  checkResponseTagExistInRequest  =((new SuplementOrderCheck()).checkResponseTagExistInRequest())
[condition][]it is not true that_the value of {field} not_equals the occurences of{section}{subsectn}=(!(virtualsaliValueOfFieldNotEqualsOccurenceOfOtherSection({field},{section},{subsectn})))
[condition][]Number of occurence of Field {FieldXpath} is in range from {minvalue} To {maxvalue}=((new Occurence(xcb.getXmlInstance())).noOfOccurenceOfFieldInRange({FieldXpath},{minvalue},{maxvalue}))
[condition][]it is not true that_virtualoccurenceofVACTandUACT {section} {errorcode} =(!(virtualoccurenceofVACTandUACT({section},{errorcode})))
[condition][]it is not true that_the {fieldName} in {parentSection} is less than {fieldValue} for the {pon} {ver} {ccna} {icsc}=(!((new SuplementOrderCheck()).isCurrentDDDLessThanPreviousVersionDDD({fieldName},{parentSection},{fieldValue},(xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc})))
[condition][]it is not true that_the {field} from positions {pos1} to {pos2} is_not_populated or spaces=(!((new Populated()).rangeOfPositionIsNotPopulatedOrSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2})))
[condition][]it is not true that_the_length_of {field} is between {min} and {max} values=(!((new LengthCheck()).checkMinMaxLength((xcb.xpath({field})).stringValue(),{min},{max})))
[condition][]it is not true that_setNCLicense {var0} =(!((new SvcType()).setNCLicense({var0})))
[condition][]the {segnum} segment of the {fieldvalue} is present in the LOCATION Table=(virtualSegmentFetchAbbreviationLOCATIONTable({segnum},{fieldvalue}))
[condition][]alloccuranceof field{path} not_equals values{commaseperatedvalues}=((new Occurence(xcb.getXmlInstance())).allOccurenceOfFieldNotEqualsValues({path},{commaseperatedvalues}))
[condition][]it is not true that_noOfOccurenceGreaterThanValue {var0} {var1} =((new Occurence(xcb.getXmlInstance())).noOfOccurenceGreaterThanValue({var0},{var1}))
[condition][]it is not true that_the {field} is AlphaNumeric=(!((new DatatypeCheck()).checkAlphaNumeric((xcb.xpath({field})).stringValue())))
[condition][]timeFormatWithRange {var0} {var1} {var2} =((new TimeFormatCheck()).timeFormatWithRange({var0},{var1},{var2}))
[condition][]the {field} has_both uppercase and lowercase characters=((new CapitalLetterCheck()).isUpperAndLowerCase((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_virtualSegmentCount {var0} =(!(virtualSegmentCount({var0})))
[condition][]the {field} has_the segment with specified {segnum} whose length is greater than specified {length}=((new LengthCheck()).segmentNumberLengthGreaterThan((xcb.xpath({field})).stringValue(),{segnum},{length}))
[condition][]it is not true that_the difference between {fielddate1} and {fielddate2} is less than one year=(!((new DateCheck()).isRangeLesserThanOneYear({fielddate1},{fielddate2})))
[condition][]it is not true that_the {field} has_all uppercase characters=(!((new CapitalLetterCheck()).isAllUpperCase((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} is less than {value}=(!((new Equals()).isLessThan((xcb.xpath({field})).stringValue(),{value})))
[condition][]firstPositionRangeGreaterThanSecondPositionRange {var0} {var1} {var2} {var3} {var4} =((new Position()).firstPositionRangeGreaterThanSecondPositionRange({var0},{var1},{var2},{var3},{var4}))
[condition][]the {field} at the position {start} to {end} does not contain any Alpha Numeric characters =((new RangeOfValues()).noExistenceOfAlpha_NumericAtSpecRange((xcb.xpath({field})).stringValue(),{start},{end}))
[condition][]the {field} is according to the specified {format}=((new SpecialFormat()).isFieldAccordingToFormat((xcb.xpath({field})).stringValue(),{format}))
[condition][]characterPreceededOrFollowedByNumeric {var0} {var1} =((new Contains()).characterPreceededOrFollowedByNumeric({var0},{var1}))
[condition][]all tags of unimapping {section} in current and previous version check {sup} {pon} {ver} {ccna} {icsc} {uact} {values} {uref} with {code}=((new Occurence(xcb.getXmlInstance())).VirtualUnimappingTagsCheckWIthPreviousVer({section},{sup},(xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{uact},{values},{uref},{code}))
[condition][]it is not true that_the {field} has_AND which is preceeded and followed by space=(!((new SpaceCheck()).isAndPrecFollSpace((xcb.xpath({field})).stringValue())))
[condition][]routing matrix 1 value check when any ALL is present{section}{subsect}{field}=((new Occurence(xcb.getXmlInstance())).routingMatrixCheck1({section},{subsect},{field}))
[condition][]the {field} has_an abbreviation name=((new ThoroughFareHelper()).fetchAbbreviationName((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_routing matrix 1 value check when any ALL is present{section}{subsect}{field}=((new Occurence(xcb.getXmlInstance())).routingMatrixCheck1({section},{subsect},{field}))
[condition][]it is not true that_spaceFollowedBySpaceFollowedByChar {var0} =(!((new SpaceCheck()).spaceFollowedBySpaceFollowedByChar({var0})))
[condition][]it is not true that_the{section}{subsect}{field} populated and assosiated tag{tag}is_not_populated or corresponding section tag{corrstag}not_equals to {values}=(!(virtualLrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues({section},{subsect},{field},{tag},{corrstag},{values})))
[condition][]responseMaximumLengthCheck {var0} {var1} {var2} {var3} =((new Occurence(xcb.getXmlInstance())).responseMaximumLengthCheck({var0},{var1},{var2},{var3}))
[condition][]the {field} is Alpha without Special Characters Set {setofspecialcharacters}=((new DatatypeCheck()).checkAlphaWithOutSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters}))
[condition][]it is not true that_the {field} is_equal_to_values {CommaSeparatedValues}=(!((new Equals()).isEqualToValues((xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]routing matrix value check when any ALL is present{section}{subsect}{field}=(virtualRoutingMatrixCheck1({section},{subsect},{field}))
[condition][]it is not true that_the {field} not_equal_to specified {value} of the specified {segnum}=(!((new Equals()).segmentValueNotEqualToEnteredValue((xcb.xpath({field})).stringValue(),{value},{segnum})))
[condition][]it is not true that_the position_of Alpha is {pos} in {field}=(!((new DatatypeCheck()).checkPositionAlpha({pos},(xcb.xpath({field})).stringValue())))
[condition][]confirmationOrderCheckDes pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=((new SuplementOrderCheck()).confirmationOrderCheckDes((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{description}))
[condition][]it is not true that_the {field} has_date format check1 {format1}=(!((new DateFormatCheck()).dateCheck1((xcb.xpath({field})).stringValue(),{format1})))
[condition][]{field} has_atleast {occurance} occurances populated=((new Occurence(xcb.getXmlInstance())).atleastOccurenceOfTagPopulated({field},{occurance}))
[condition][]it is not true that_the {field} is Numeric without Special Characters Set {setofspecialcharacters}=(!((new DatatypeCheck()).checkNumericWithOutSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters})))
[condition][]all occurences of{fieldwithxpath} not_equals to{value}=((new Occurence(xcb.getXmlInstance())).allOccurenceOfFieldNotEqualToValue({fieldwithxpath},{value}))
[condition][]it is not true that_there is no {field} section=(!((new Populated()).isNotPopulated((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_Check for reqtyp{field} pon{field}ver{ver}ccna{ccna}icsc{icsc}=(!((new SuplementOrderCheck()).reqtypFieldCheck((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc})))
[condition][]the {section} for lref when uact is_not_equal_to CKT with {errorcode}=(virtuallrefProhibitedWhenUactNotEqualsCNK({section},{errorcode}))
[condition][]the {field} is compared with its position {pos1} to {pos2} with values {values}=((new Position()).compareCharAtAnyPositionWithAnyNumberOfValue((xcb.xpath({field})).stringValue(),{pos1},{pos2},{values}))
[condition][]it is not true that_checkCancelledUrefExists {var0} {var1} {var2} {var3} {var4} {var5} {var6} =(!((new SuplementOrderCheck()).checkCancelledUrefExists({var0},{var1},{var2},{var3},{var4},{var5},{var6})))
[condition][]it is not true that_the{section} {field} is not unique in all the occurences with code {code}=((new Occurence(xcb.getXmlInstance())).isUnique({section},{field},{code}))
[condition][]noOfOccurence {var0} =((new Occurence(xcb.getXmlInstance())).noOfOccurence({var0}))
[condition][]The {field} contains whitespaces or numbers in range or zeros from second position_to end=((new Position()).charAtPositionCheck((xcb.xpath({field})).stringValue()))
[condition][]the {field} has_specified range {start} to {end}=((new RangeOfValues()).rangeCheckNN_NN((xcb.xpath({field})).stringValue(),{start},{end}))
[condition][]it is not true that_lrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue {var0} {var1} {var2} {var3} {var4} {var5} {var6} =((new Occurence(xcb.getXmlInstance())).lrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]atleast one occurence of{section}{subsectn} is populated=(virtualsaliAtleastOneOccurenceSectionPopulated({section},{subsectn}))
[condition][]it is not true that_the_section{section} with the_field {field} is not consecutively assigned from value{value} with errorcode {errorcode}=(!(virtualFieldIsNotConsecutivelyAssignedAcrossOccurrences({section},{field},{value},{errorcode})))
[condition][]it is not true that_the {field} has_valid values {commaseperatedvalues}=(!((new isValidValue()).isValidValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]it is not true that_anyOccurenceOfMultipleFieldIsPopulatedAndNotNumeric {var0} =((new Occurence(xcb.getXmlInstance())).anyOccurenceOfMultipleFieldIsPopulatedAndNotNumeric({var0}))
[condition][]it is not true that_the {field} contains embedded space=(!((new SpaceCheck()).containsEmbeddedSpace((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the_field {fieldname} with parent section {parentname} is populated in previous version for the pon {PON} ver {VER} ccna {CCNA} and icsc {ICSC}=(!((new SuplementOrderCheck()).fieldPopulatedInPreviousVersion({fieldname},{parentname},(xcb.xpath({PON})).stringValue(),(xcb.xpath({VER})).stringValue(),(xcb.xpath({CCNA})).stringValue(),{ICSC})))
[condition][]it is not true that_the maximum length of {field} is {value}=(!((new LengthCheck()).checkMaximumlength((xcb.xpath({field})).stringValue(),{value})))
[condition][]the {field} is equal or greater than {value}=((new Equals()).isEqualOrGreaterThan((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_characterPreceededOrFollowedByNumeric {var0} {var1} =(!((new Contains()).characterPreceededOrFollowedByNumeric({var0},{var1})))
[condition][]Is the {fieldDate1} less than {comparisonDate} in the format {CCYYMMDD}=((new DateFormatCheck()).isFieldDateLessThanComparisonDateInspecifiedFormat({fieldDate1},{comparisonDate},{CCYYMMDD}))
[condition][]it is not true that_the {field} has_consecutive uppercase characters and should not be followed by space=(!((new CapitalLetterCheck()).consecUpperCaseWithNoSpaceAfter((xcb.xpath({field})).stringValue())))
[condition][]setSvcName {var0} =((new SvcType()).setSvcName({var0}))
[condition][]any of the occurance of {fieldwithxpath} exists=((new Occurence(xcb.getXmlInstance())).anyOccurenceExists({fieldwithxpath}))
[condition][]it is not true that_getSaliParent of{parent} in{section} for{tag}=((new Occurence(xcb.getXmlInstance())).getSaliParent({parent},{section},{tag}))
[condition][]the {field} has_a valid value {value}=((new isValidValue()).isValidValue((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the CKTACT field check pon{pon} ver{ver} ccna{ccna} icsc{icsc} and xpath{xpath} tag{tag} with value{value} for rule{ruleErrorCode}=((new Occurence(xcb.getXmlInstance())).cktActCheck((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{xpath},{tag},{value},{ruleErrorCode}))
[condition][]it is not true that_virtualuactValueCheckWithPreviousVersion {section} {sup} {pon} {ver} {ccna} {icsc} {uact} {value} {uref} with {code} =((new Occurence(xcb.getXmlInstance())).VirtualUactValueCheckWithPreviousVersion({section},{sup},(xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{uact},{value},{uref},{code}))
[condition][]the difference between {fielddate1} and {fielddate2} is less than or equal to one year=((new DateCheck()).isRangeLesserThanOrEqualToOneYear({fielddate1},{fielddate2}))
[condition][]the difference between {fielddate1} and {fielddate2} is less than one year=((new DateCheck()).isRangeLesserThanOneYear({fielddate1},{fielddate2}))
[condition][]it is not true that_the{section}{subsect}{field}not populated and assosiated tag{tag}is populated and corresponding section tag{corrstag}equals to {values}=(!(virtualLrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue({section},{subsect},{field},{tag},{corrstag},{values})))
[condition][]noconfirmationOrderCheckNew pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}dedicate_recieve_customer{drc}=((new SuplementOrderCheck()).noConfirmationOrderCheckNew((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{description},{drc}))
[condition][]it is not true that_the {fieldwithxpath} is not required=(!((new Required()).isNotRequired({fieldwithxpath})))
[condition][]it is not true that_positionOfAllFieldNotEqualToCharacter {var0} {var1} {var2} =((new Occurence(xcb.getXmlInstance())).positionOfAllFieldNotEqualToCharacter({var0},{var1},{var2}))
[condition][]it is not true that_the {field} is_not_equal_to specified val {val}=(!((new Equals()).fieldnoteqval((xcb.xpath({field})).stringValue(),{val})))
[condition][] new SuplementOrderCheck  checkTagValueInRequestforResponse  =((new SuplementOrderCheck()).checkTagValueInRequestforResponse())
[condition][]the difference between {fielddate1} and {fielddate2} is greater than specified {fieldmonths}=((new DateCheck()).isRangeGreaterThanSpecifiedMonths({fielddate1},{fielddate2},{fieldmonths}))
[condition][]it is not true that_the multiple field{field} has_length greater than{value} in any occurence=((new Occurence(xcb.getXmlInstance())).lengthCheckForMultipleOccuringTag({field},{value}))
[condition][]the each position_from {pos1} to {pos2} of {field} is not in between {startrange} and {endrange}=((new RangeOfValues()).checkPositionsInRangeNotPopulatedInRangeOfValues({pos1},{pos2},(xcb.xpath({field})).stringValue(),{startrange},{endrange}))
[condition][]it is not true that_the position_of Special Character is {pos} in {field}=(!((new DatatypeCheck()).checkPositionSP({pos},(xcb.xpath({field})).stringValue())))
[condition][]the{field} has_the last character not_equal_to_values{value}=((new Equals()).lastCharacterOfFieldNotEqualValues((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {field} has_the specified {value} in the range {start} to {end}=(!((new RangeOfValues()).compareSpecStringInRange((xcb.xpath({field})).stringValue(),{value},{start},{end})))
[condition][]the {field} contains atleast one non space character in the range {start} to {end}=((new SpaceCheck()).checkAtleastOneNonSpaceInRange((xcb.xpath({field})).stringValue(),{start},{end}))
[condition][]it is not true that_virtualRefnumEqulasSegment {var0} {var1} =(!(virtualRefnumEqulasSegment({var0},{var1})))
[condition][]any_occurance_of_the {field1withxpath} is_equal_to {value}=((new Occurence(xcb.getXmlInstance())).anyOccurenceEqualToValue({field1withxpath},{value}))
[condition][]the {pos} and {pos} position_of the {field} is_not_equal_to {pos} and {pos} position=((new Position()).twoPositionValueofTagNotEqualToValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]it is not true that_checkAlphaNumericWithASingleSpecialCharacter {var0} {var1} =(!((new DatatypeCheck()).checkAlphaNumericWithASingleSpecialCharacter({var0},{var1})))
[condition][]it is not true that_the maximum length of the trimmed field {fieldvalue} is {length}=(!(virtualCheckMaximumLengthOfTrimmedTag({fieldvalue},{length})))
[condition][]the pos{pos1} to {pos2} of the_field {field} with specified segment {segnum} is_equal_to the pos{pos1} to {pos2} of another field {field}=((new Position()).segmentInPositionRangeEqualToNextFieldSpecifiedPositionRange({pos1},{pos2},(xcb.xpath({field})).stringValue(),{segnum},{pos1},{pos2},(xcb.xpath({field})).stringValue()))
[condition][]the {field} has_only one {char} special character present=((new DatatypeCheck()).checkRepeationOFSpecialCharacter((xcb.xpath({field})).stringValue(),{char}))
[condition][]atleast any one of the segment delimeted by the char {delimchar} of the {field} does not contain Alpha character followed by maximum number {num} of numeric characters=(virtualSegmentsDoesNotContainsAlphafollowedByNumerics({delimchar},(xcb.xpath({field})).stringValue(),{num}))
[condition][]it is not true that_The number of occurence of {path} populated is greater than {number}=((new Occurence(xcb.getXmlInstance())).NumberOfoccurencepopulatedisgreaterthan({path},{number}))
[condition][]it is not true that_any of the {fieldwithxpath} has {character}=((new Occurence(xcb.getXmlInstance())).anyCharacterOfFieldIs({fieldwithxpath},{character}))
[condition][]the {field} is Numeric=((new DatatypeCheck()).checkNumeric((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {fieldwithxpath} occurance is atmost {numberoftimes}=((new Occurence(xcb.getXmlInstance())).atmostOccurenceOf({fieldwithxpath},{numberoftimes}))
[condition][]the interval between {fielddate1} and {fielddate2} is greater than {days}=((new DateCheck()).intervalBetweenTwoDateIsGreaterThanDays({fielddate1},{fielddate2},{days}))
[condition][]it is not true that_the interval between {fielddate1} and {fielddate2} is greater than or equal to {days}=(!((new DateCheck()).intervalBetweenTwoDateIsGreaterThanOrEqualToDays({fielddate1},{fielddate2},{days})))
[condition][]virtualoccurenceofVACTandUACTCEVLAN {var0} {var1} =(virtualoccurenceofVACTandUACTCEVLAN({var0},{var1}))
[condition][]any segment of the {fieldvalue} delimeted by space does not equal {commaseparatedvalues}=((new LengthCheck()).segmentsNotEquals({fieldvalue},{commaseparatedvalues}))
[condition][]the ccna {fieldvalue} has_the license for the table {NCNCIICSCCLLI}=((new ASOGTABLE()).checkCcnaLicenseForTable({fieldvalue},{NCNCIICSCCLLI}))
[condition][]it is not true that_any_occurance_of_the {field1withxpath} is_equal_to {value}=((new Occurence(xcb.getXmlInstance())).anyOccurenceEqualToValue({field1withxpath},{value}))
[condition][]the {field} is Alpha with Special Characters=((new DatatypeCheck()).checkAlphaSP((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} with segment{segnum} is populated=(!((new DatatypeCheck()).segmentPopulated((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]the {field} contains {num} of consecutive lowercase Alpha Characters=((new CapitalLetterCheck()).containsConsecutiveLowercaseAlphaCharacters((xcb.xpath({field})).stringValue(),{num}))
[condition][]it is not true that   new SuplementOrderCheck  checkTagValueInRequestforResponse  =(!((new SuplementOrderCheck()).checkTagValueInRequestforResponse()))
[condition][]it is not true that_the table {tablename} does not exists in the data base=(!((new ASOGTABLE()).checkNonExistenceOfTable({tablename})))
[condition][]the_section {section} for the field {feild} with {compvalue} and {innercompvalue} for field {innerfeild} and {errorcode}=(virtualoccurenceofSvlanMapping({section},{feild},{compvalue},{innercompvalue},{innerfeild},{errorcode}))
[condition][]CHECK FIRMORDER request{field} pon{field} ver{field} ccna{field} icsc{field}=((new SuplementOrderCheck()).firmOrderToServiceRequestCheck((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue()))
[condition][]the interval duration is blank for the {ccna} {nc} and {icsc}=((new IntervalDurationMatcher()).isIntervalExisting((xcb.xpath({ccna})).stringValue(),{nc},{icsc}))
[condition][]it is not true that_setNCNCICompatibilityLicense  {var0} =(!((new SvcType()).setNCNCICompatibilityLicense({var0})))
[condition][]it is not true that_the {field} has_an abbreviation name=(!((new ThoroughFareHelper()).fetchAbbreviationName((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_segmentEqualToAlphaNumericWithSPChar {var0} {var1} {var2} =(!((new DatatypeCheck()).segmentEqualToAlphaNumericWithSPChar({var0},{var1},{var2})))
[condition][]the {field} is_not_equal_to specified val {val}=((new Equals()).fieldnoteqval((xcb.xpath({field})).stringValue(),{val}))
[condition][]it is not true that_set the request type of to {var0}=(!((new ReqTypeAct()).setRequestType({var0})))
[condition][]it is not true that_the {fielddate1} is a Weekend=(!((new DateCheck()).isHoliday({fielddate1})))
[condition][]the_field {field} populated with segment {segno} with optional character {character} does not contain {startLength} to {endLength} Alpha Numerics=((new LengthCheck()).checkSegmentNotPopulatedInLengthWithOptionalCharacter((xcb.xpath({field})).stringValue(),{segno},{character},{startLength},{endLength}))
[condition][]it is not true that_the {sectn} has_the naickt{naiSectn} for the cancelled refnum{field} with value{value}=(!(virtualAnyNAICKTcheckForCancelledUREF({sectn},{naiSectn},{field},{value})))
[condition][]it is not true that_The field Date is a valid date in the format mmddyy=(!((new DateCheck()).isValidDate2()))
[condition][]it is not true that_the {field}is_not_equal_to_values {CommaSeparatedValues}=(!((new Equals()).isNotEqualToValues((xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]it is not true that_the CCNA has_license for NCI Table=(!((new SvcType()).getNCILicense()))
[condition][]it is not true that_the {pos} position_of {field1} is_equal_to {pos} position_of {field2}=(!((new Position()).positionOfOneFieldIsEqualToPositionOfAnother({pos},{field1},{pos},{field2})))
[condition][]it is not true that_the{section}{field} lengths not_equals{value} with code {code}=(!(virtualResponseLengthCheck({section},{field},{value},{code})))
[condition][]it is not true that_the {pos1} to {pos2} of the {field} is present in LOCATION Table=(!((new ASOGTABLE()).posToPosfetchAbbreviationLOCATIONTable({pos1},{pos2},(xcb.xpath({field})).stringValue())))
[condition][]AnyOccoffield1withsection{multiecoec} field1 {OECICSC}equals field2{field2} with values {value1} and {value2} with errorCode {errorcode}=(virtualAnyOccoffield1equalsvaluewherefield2notequalsvalue({multiecoec},{OECICSC},{field2},{value1},{value2},{errorcode}))
[condition][]it is not true that_the {fieldvalue} is present in NCI table =(!((new ASOGTABLE()).fetchAbbreviationNCITable({fieldvalue})))
[condition][]it is not true that_virtualoccurenceofuactNCIRuid {vector} {list} {ncivalue} {errorcode} =(!(virtualoccurenceofuactNCIRuid({vector},{list},{ncivalue},{errorcode})))
[condition][]the value of {field} not_equals the occurences of{section}=(virtualsaliValueOfFieldNotEqualsOccurenceOfOtherSection1({field},{section}))
[condition][]it is not true that_the_fields NC {NC} NCI {NCI} and SECNCI {SECNCI} are not compatible with database=(!((new ASOGTABLE()).checkNcNciCompatibility({NC},{NCI},{SECNCI})))
[condition][]the {field} has_specified {segmentNumber} not_equal_to numeric=((new DatatypeCheck()).segmentNotEqualToNumeric((xcb.xpath({field})).stringValue(),{segmentNumber}))
[condition][]the {field} has_last character as upper which is followed by lower case character=((new CapitalLetterCheck()).lastCharUpperFollLower((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the sup {SupFieldValue} is populated with act {ActFieldValue} and pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} on the current order and does not have same ACT on the previous order=(!((new SuplementOrderCheck()).actFieldCheck({SupFieldValue},{ActFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue})))
[condition][]it is not true that_the ICSC has_license for CLLI Table=(!((new SvcType()).getIcscCLLILicense()))
[condition][]it is not true that_the {fieldvalue} is present in NC table =(!((new ASOGTABLE()).fetchAbbreviationNCTable({fieldvalue})))
[condition][]it is not true that_virtualCanopiWebService {var0} =(!(virtualCanopiWebService({var0})))
[condition][]it is not true that_the {field} is Alpha with Special Characters Set {setofspecialcharacters}=(!((new DatatypeCheck()).checkAlphaSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters})))
[condition][]the {field} contains {num} of consecutive uppercase Alpha Characters=((new CapitalLetterCheck()).containsConsecutiveUppercaseAlphaCharacters((xcb.xpath({field})).stringValue(),{num}))
[condition][]the {field} has_all lowercase characters for comma seperated values=((new CapitalLetterCheck()).isAllLowerCaseForCSV((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_routing matrix value check when first column is ALL{section}{subsect}{field}=(!(virtualRoutingMatrixCheck2({section},{subsect},{field})))
[condition][]the maximum length of the trimmed field {fieldvalue} is {length}=(virtualCheckMaximumLengthOfTrimmedTag({fieldvalue},{length}))
[condition][]the {pos} position_of {field} is_not_equal_to_values {commaseperatedvalues}=(virtualPositionOftagValueNotEqualToValues({pos},(xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]virtualALCONfieldPopulated {priloc} {secloc} {errorcode} =(virtualALCONfieldPopulated({priloc},{secloc},{errorcode}))
[condition][]it is not true that_any occurence of the {fieldwithxpath} is populated in Response=((new Occurence(xcb.getXmlInstance())).anyOccurenceOfFieldPopulatedInRespose({fieldwithxpath}))
[condition][]the {field} is_equal_to_values {CommaSeparatedValues}=((new Equals()).isEqualToValues((xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]it is not true that_virtualoccurenceofuactRuid {vector} {list} {errorcode} =((new Occurence(xcb.getXmlInstance())).virtauloccurenceofuactRuid({vector},{list},{errorcode}))
[condition][]it is not true that   new SvcType  getSvcName  =(!((new SvcType()).getSvcName()))
[condition][]the {field} contains {CommaSeparatedValues}=((new Contains()).contains((xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]setSvcNameUOM {var0} =((new SvcType()).setSvcNameUOM({var0}))
[condition][]it is not true that_presenceOfSpaceOtherThanSpecifiedPosition {var0} {var1} =(!((new Position()).presenceOfSpaceOtherThanSpecifiedPosition({var0},{var1})))
[condition][]the {fielddate1} is greater than or equal to {fielddate2}=((new DateCheck()).isGreaterThanOrEqualTo({fielddate1},{fielddate2}))
[condition][]virtualuactValueCheckWithPreviousVersion {section} {sup} {pon} {ver} {ccna} {icsc} {uact} {value} {uref} with {code} =((new Occurence(xcb.getXmlInstance())).VirtualUactValueCheckWithPreviousVersion({section},{sup},(xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{uact},{value},{uref},{code}))
[condition][]it is not true that_the {field} has_from the start position {pos} to end position {pos} the constant {constant} followed by a Dot and followed by {number} alphanumeric characters=(!((new DatatypeCheck()).constantFollowedByDotFollowedByAlphaNumeric((xcb.xpath({field})).stringValue(),{pos},{pos},{constant},{number})))
[condition][]it is not true that_the {field} has_words seperated by a comma=(!((new DatatypeCheck()).commaPresenceForMoreThanOneWord((xcb.xpath({field})).stringValue())))
[condition][]the {field} has_two or more uppercase alphabets=((new CapitalLetterCheck()).twoOrMoreConsecUpperCaseAlpha((xcb.xpath({field})).stringValue()))
[condition][]any Occurnce of {fieldwithxpath} is_equal_to {character} in {pos}positon=((new Occurence(xcb.getXmlInstance())).positionOfAnyFieldEqualToCharacter({fieldwithxpath},{character},{pos}))
[condition][]it is not true that_{field} has_atleast {occurance} occurances populated=((new Occurence(xcb.getXmlInstance())).atleastOccurenceOfTagPopulated({field},{occurance}))
[condition][]the {field} is not numeric with special character set{spcharacters}=((new DatatypeCheck()).notNumericWithAllSpSet((xcb.xpath({field})).stringValue(),{spcharacters}))
[condition][]it is not true that_the_field {field} is numeric with the last character as the {char}=(!((new DatatypeCheck()).numericWithLastCharacter((xcb.xpath({field})).stringValue(),{char})))
[condition][]it is not true that_the {field} is populated with {numberofsegment} segments=(!((new LengthCheck()).numberOfSegments((xcb.xpath({field})).stringValue(),{numberofsegment})))
[condition][]it is not true that_the{section}{field}is populated and assosiated tag{tag} not_equals to values{values}=(!(virtualAnyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues({section},{field},{tag},{values})))
[condition][]checkForLowerCaseLettersAfterNumbers {var0} =((new CapitalLetterCheck()).checkForLowerCaseLettersAfterNumbers({var0}))
[condition][]the {field} has_from the start position {pos} to end position {pos} the constant {constant} followed by a Dot and followed by {number} alphanumeric characters=((new DatatypeCheck()).constantFollowedByDotFollowedByAlphaNumeric((xcb.xpath({field})).stringValue(),{pos},{pos},{constant},{number}))
[condition][]it is not true that_section{section} tag{tag} not populated=(!(virtualNotPopulated({section},{tag})))
[condition][]containsSpaceInSpecRange {var0} {var1} {var2} =((new Contains()).containsSpaceInSpecRange({var0},{var1},{var2}))
[consequence][]setSvcName {var0} =((new SvcType()).setSvcName({var0}))
[consequence][]setNCLicense {var0} =((new SvcType()).setNCLicense({var0}))
[condition][]it is not true that_the {field} has_virgule or period as delimiter=(!((new DatatypeCheck()).fieldHasOneDelimiter((xcb.xpath({field})).stringValue())))
[condition][]any occurence of the {fieldwithxpath} is_not_populated in Response=((new Occurence(xcb.getXmlInstance())).anyOccurenceOfFieldNotPopulatedinResponse({fieldwithxpath}))
[condition][]it is not true that_virtualoccOfOTCnEVMPIDwithinsameUNIMAPPING {section} {errorcode} =(!(virtualoccOfOTCnEVMPIDwithinsameUNIMAPPING({section},{errorcode})))
[condition][]it is not true that_firstPositionRangeGreaterThanSecondPositionRange {var0} {var1} {var2} {var3} {var4} =(!((new Position()).firstPositionRangeGreaterThanSecondPositionRange({var0},{var1},{var2},{var3},{var4})))
[condition][]it is not true that_atleast any one of the segment delimeted by the char {delimchar} of the {field} does not contain Alpha character followed by maximum number {num} of numeric characters=(!(virtualSegmentsDoesNotContainsAlphafollowedByNumerics({delimchar},(xcb.xpath({field})).stringValue(),{num})))
[condition][]it is not true that_the {fieldwithxpath} is required=(!((new Required()).isRequired({fieldwithxpath})))
[condition][]the {pos} position_Of {field1} equal to {pos} position_Of {field2}=((new Contains()).positionOfFieldEqualToPositionOfField({pos},{field1},{pos},{field2}))
[condition][]it is not true that_the message type for the valid interface equals {values}=(!((new SuplementOrderCheck()).checkMessageType({values})))
[condition][]the pon {field} ver {field} section {section} tag {tag} at {pos} is populated in Request against Response=((new SuplementOrderCheck()).checkResponseTagExistInRequestatPosition((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag},{pos}))
[condition][]the {field} has_valid values {commaseperatedvalues}=((new isValidValue()).isValidValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]noOfCharactersinTag {var0} {var1} {var2} =((new Contains()).NoOfCharactersinTag({var0},{var1},{var2}))
[condition][]it is not true that_setICSCNCNCICompatibilityLicense {var0} =(!((new SvcType()).setICSCNCNCICompatibilityLicense({var0})))
[condition][]existenceOfSpaceInEntireRange {field} {range1} {range2} =((new SpaceCheck()).existenceOfSpaceInEntireRange((xcb.xpath({field})).stringValue(),{range1},{range2}))
[condition][]it is not true that_Number of occurence of Field {FieldXpath} is in range from {minvalue} To {maxvalue}=((new Occurence(xcb.getXmlInstance())).noOfOccurenceOfFieldInRange({FieldXpath},{minvalue},{maxvalue}))
[condition][]it is not true that_any occurence of field{section}{field} is_not_populated and assosiated tag{tag} equals {values} and corresponding tag{tag} equals {values}=(!(virtualAnyOccurenceOfFieldNotPopulatedAndAssosiatedTagEqualsValuesAndCorrespondingTagEqualsValues({section},{field},{tag},{values},{tag},{values})))
[condition][]the range of the {field} is AA to ZZ=((new RangeOfValues()).rangeCheckAA_ZZ((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_duplicate order pon {pon} ver {ver} ccna {ccna} hdricsc {icsc} exists in DB=(!((new SuplementOrderCheck()).duplicateOrderCheckWithHDRICSC((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc})))
[condition][]the {fieldvalue} is present in the LOCATION table=((new ASOGTABLE()).fetchAbbreviationLOCATIONTable({fieldvalue}))
[condition][]it is not true that_the {field} is not Required=(!((new Required()).isNotRequired((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} does not match with {compstring} having the specified Characters {numChar} from last within the comparison string=(!((new Position()).CompStringDoesntMatchWithSpecifiedChars((xcb.xpath({field})).stringValue(),{compstring},{numChar})))
[condition][]it is not true that_virtualOccurenceofEIandUACTinUNIMAPPING {section} {errorcode} =(!(virtualOccurenceofEIandUACTinUNIMAPPING({section},{errorcode})))
[condition][]it is not true that_the {field} contains trailing space character=(!((new SpaceCheck()).checktrailspaces((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the pos{pos1} to {pos2} of the_field {field} with specified segment {segnum} is_equal_to the pos{pos1} to {pos2} of another field {field}=(!((new Position()).segmentInPositionRangeEqualToNextFieldSpecifiedPositionRange({pos1},{pos2},(xcb.xpath({field})).stringValue(),{segnum},{pos1},{pos2},(xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the minimum length of {field} is {value}=(!((new LengthCheck()).checkMinimumLength((xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_the {field} is not numeric with special character set{spcharacters}=(!((new DatatypeCheck()).notNumericWithAllSpSet((xcb.xpath({field})).stringValue(),{spcharacters})))
[condition][]it is not true that_eachCharacterPreceededOrFollowedByNumeric {var0} {var1} =(!((new Contains()).eachCharacterPreceededOrFollowedByNumeric({var0},{var1})))
[condition][]comparePrevVerAndCurrVerFieldValue {var0} {var1} {var2} {var3} {var4} {var5} {var6} {var7} {var8} {var9} {var10} =((new SuplementOrderCheck()).comparePrevVerAndCurrVerFieldValue({var0},{var1},{var2},{var3},{var4},{var5},{var6},{var7},{var8},{var9},{var10}))
[condition][]the {fieldvalue} is in HHMMA HHMMP format and the difference is_equal_to or greater than {value} hours=((new TimeFormatCheck()).appointmentTimeFormatRange({fieldvalue},{value}))
[condition][]it is not true that_Is the {field} of the specified {segnum} according to the format {format}=(!((new DateFormatCheck()).isSpecifiedSegmentInValidFormat((xcb.xpath({field})).stringValue(),{segnum},{format})))
[condition][]the difference between {fielddate1} and {fielddate2} is_equal_to one year=((new DateCheck()).isRangeEqualToOneYear({fielddate1},{fielddate2}))
[condition][]getvalue {var0} =((new Occurence(xcb.getXmlInstance())).getvalue({var0}))
[condition][]it is not true that_the {field} is compared with the specified {segnum} at the positions {pos1} to {pos2} with the specified {value}=(!((new Position()).compareSpecifiedSegmentWithCharPositionInValue((xcb.xpath({field})).stringValue(),{segnum},{pos1},{pos2},{value})))
[condition][]it is not true that_the substring upto colon of the {field} equals {values}=(!((new SvcType()).compareSvcType((xcb.xpath({field})).stringValue(),{values})))
[condition][]the interface name does not exist=((new SuplementOrderCheck()).checkInterfaceId())
[condition][]the difference for the given {CCNA} {NC} and {ICSC} between the {ASRDDD} and the current date is less than the Interval Duration from the table=((new IntervalDurationMatcher()).isIntervalDurationMatching((xcb.xpath({CCNA})).stringValue(),{NC},{ICSC},{ASRDDD}))
[condition][]it is not true that_virtualALCONfieldPopulated {priloc} {secloc} {errorcode} =(!(virtualALCONfieldPopulated({priloc},{secloc},{errorcode})))
[condition][]noconfirmationOrderCheckDes pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=((new SuplementOrderCheck()).noConfirmationOrderCheckDes((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{description}))
[condition][]the {field} has_AND which is preceeded and followed by space=((new SpaceCheck()).isAndPrecFollSpace((xcb.xpath({field})).stringValue()))
[condition][]the {fieldvalue} is populated in segment {segnum} after {value}=(virtualPositionAfterDelimeterPopulated({fieldvalue},{segnum},{value}))
[condition][]it is not true that_timeFormatWithRange {var0} {var1} {var2} =(!((new TimeFormatCheck()).timeFormatWithRange({var0},{var1},{var2})))
[condition][]vitualsvlanthirdOccurenceProhibit {vector} {errorcode} =((new Occurence(xcb.getXmlInstance())).vitualsvlanthirdOccurenceProhibit({vector},{errorcode}))
[condition][]the_field {field} with segment {segnum} is populated=((new Populated()).segmentIsPopulated((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]it is not true that_atleast one occurence of{section} is populated=(!(virtualsaliAtleastOneOccurenceSectionPopulated1({section})))
[consequence][]setSvcNameUOM {var0} =((new SvcType()).setSvcNameUOM({var0}))
[condition][]it is not true that_the_field {field} has_pattern {pattern}=(!((new SpecialFormat()).patternChecking((xcb.xpath({field})).stringValue(),{pattern})))
[condition][]the {fieldwithxpath} is not prohibited=((new Prohibited()).isNotProhibited({fieldwithxpath}))
[condition][]the message type for the valid interface equals {values}=((new SuplementOrderCheck()).checkMessageType({values}))
[condition][]it is not true that_if {pos1} and {pos2} not in foramt {chhp} for {fdt}=(!((new DateFormatCheck()).time_format_chkforFDT({pos1},{pos2},{chhp},{fdt})))
[condition][]it is not true that_the {field} contains all lowercase alpha character directly preceded by a numeric character=(!((new CapitalLetterCheck()).lowercaseAlphapreceededByNumeric((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} has_date format as check3 {YYMMDD}=(!((new DateFormatCheck()).dateCheck3((xcb.xpath({field})).stringValue(),{YYMMDD})))
[condition][]any_occurance_of_the {field1withxpath} is_equal_to comma seperated values{values}=((new Occurence(xcb.getXmlInstance())).anyOccurenceEqualToValues({field1withxpath},{values}))
[condition][]spaceFollowedBySpace {var0} =((new Contains()).spaceFollowedBySpace({var0}))
[condition][]the {field} has_alpha characters in the specified range {start} to {end}=((new RangeOfValues()).numberOfAlphaInSpecRange((xcb.xpath({field})).stringValue(),{start},{end}))
[condition][]it is not true that_the {field} has_all lowercase characters=(!((new CapitalLetterCheck()).isAllLowerCase((xcb.xpath({field})).stringValue())))
[condition][]the {field} has_the specified segment with number {segnum} whose length is in range {min} to {max} to support virgule or period as delimiter=((new LengthCheck()).virguleandPeriodSegmentNumberLengthInRange((xcb.xpath({field})).stringValue(),{segnum},{min},{max}))
[condition][]the {pos1} to {pos2} of the {field} is present in LOCATION Table=((new ASOGTABLE()).posToPosfetchAbbreviationLOCATIONTable({pos1},{pos2},(xcb.xpath({field})).stringValue()))
[condition][] new ReqTypeAct  getActivity  =((new ReqTypeAct()).getActivity())
[condition][]it is not true that_the interval between {fielddate1} and {fielddate2} is less than {days}=(!((new DateCheck()).intervalBetweenTwoDateIsLessThanDays({fielddate1},{fielddate2},{days})))
[condition][]it is not true that_all occurence of{section}{field} not_equals{value} erroring to last occurence with{errorcode}=(!(virtualAllOccurenceOfFieldNotEqualsValue({section},{field},{value},{errorcode})))
[condition][]it is not true that_virtualoccurenceofVACTandUACT3CEVLAN {var0} {var1} =(!(virtualoccurenceofVACTandUACT3CEVLAN({var0},{var1})))
[condition][]it is not true that_the {fieldwithxpath} occurance is atleast {numberoftimes}=((new Occurence(xcb.getXmlInstance())).atleastOccurenceOf({fieldwithxpath},{numberoftimes}))
[condition][]noconfirmationOrderCheck pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=((new SuplementOrderCheck()).noConfirmationOrderCheck((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{description}))
[condition][]the {fieldwithxpath} occurance is atmost {numberoftimes}=((new Occurence(xcb.getXmlInstance())).atmostOccurenceOf({fieldwithxpath},{numberoftimes}))
[condition][]it is not true that_the {fielddate1} is greater than or equal to {fielddate2}=(!((new DateCheck()).isGreaterThanOrEqualTo({fielddate1},{fielddate2})))
[condition][]the_field1 {field1} and field2 {field2} Combination is_Invalid for the Valid_field1 values {values} and combination {KVcmob}=(virtual_keyValueCombination({field1},{field2},{values},{KVcmob}))
[condition][]the {field} has_both uppercase and lowercase characters for comma seperated vaules=((new CapitalLetterCheck()).isUpperAndLowerCaseForCSV((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_virtualoccurenceofVACTandUACTCEVLAN {var0} {var1} =(!(virtualoccurenceofVACTandUACTCEVLAN({var0},{var1})))
[condition][]it is not true that_the_field {fieldname} of {parentname} with value {fieldvalue} differs from previous version tag value for the pon {PON} version {VER} ccna {CCNA} and icsc{ICSC}=(!((new SuplementOrderCheck()).tagValueDiffersInPreviousVersion({fieldname},{parentname},{fieldvalue},(xcb.xpath({PON})).stringValue(),(xcb.xpath({VER})).stringValue(),(xcb.xpath({CCNA})).stringValue(),{ICSC})))
[condition][]the {field} equals {value}=((new Equals()).isEquals((xcb.xpath({field})).stringValue(),{value}))
[condition][]the {field} contains all lowercase alpha characters directly preceded by a numeric character=((new CapitalLetterCheck()).lowercaseAlphaCharactersPreceededByNumeric((xcb.xpath({field})).stringValue()))
[condition][]the {field} has_not a valid value{commaseperatedvalues}=((new isValidValue()).isNotValidValue((xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]it is not true that_the {fielddate1} is greater than {fielddate2}=(!((new DateCheck()).isGreaterThan({fielddate1},{fielddate2})))
[condition][]it is not true that_the position {pos1} and {pos2} of {field} is between {startrange} and {endrange}=(!((new RangeOfValues()).twoFieldPositionInRange({pos1},{pos2},(xcb.xpath({field})).stringValue(),{startrange},{endrange})))
[condition][]the value of {field} not_equals the occurences of{section}{subsectn}=(virtualsaliValueOfFieldNotEqualsOccurenceOfOtherSection({field},{section},{subsectn}))
[condition][]the {field} has_specified segment {segnum} which contains alpha numeric characters=((new DatatypeCheck()).segmentEqualToAlphaNumeric((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]it is not true that_the {field} has_two or more uppercase alphabets=(!((new CapitalLetterCheck()).twoOrMoreConsecUpperCaseAlpha((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_anyOccurenceOfSaliTagEqualsValue {var0} {var1} {var2} {var3} {var4} =((new Occurence(xcb.getXmlInstance())).anyOccurenceOfSaliTagEqualsValue({var0},{var1},{var2},{var3},{var4}))
[condition][]duplicate order pon {pon} ver {ver} ccna {ccna} hdricsc {icsc} exists in DB=((new SuplementOrderCheck()).duplicateOrderCheckWithHDRICSC((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc}))
[condition][]segmentRangeIsNumericWithLeadingSpaces {var0} {var1} {var2} {var3} =((new LengthCheck()).segmentRangeIsNumericWithLeadingSpaces({var0},{var1},{var2},{var3}))
[condition][]the {field} is populated with {numberofsegment} segments=((new LengthCheck()).numberOfSegments((xcb.xpath({field})).stringValue(),{numberofsegment}))
[condition][]it is not true that_the {fieldvalue} is present on ICSC table=(!((new ASOGTABLE()).fetchAbbreviationICSCTable({fieldvalue})))
[condition][]isCurrentDateLessThanOrEqualToDesiredDueDate {var0} =((new DateCheck()).isCurrentDateLessThanOrEqualToDesiredDueDate({var0}))
[condition][]it is not true that_the_section {section} for the field {feild} with {compvalue} and {innercompvalue} for field {innerfeild} and {errorcode}=(!(virtualoccurenceofSvlanMapping({section},{feild},{compvalue},{innercompvalue},{innerfeild},{errorcode})))
[condition][]it is not true that_the {field} is Numeric with Special Characters=(!((new DatatypeCheck()).checkNumericSP((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} at the position {start} to {end} does not contain any Alpha Numeric characters =(!((new RangeOfValues()).noExistenceOfAlpha_NumericAtSpecRange((xcb.xpath({field})).stringValue(),{start},{end})))
[condition][]spaceFollowedBySpaceFollowedByChar {var0} =((new SpaceCheck()).spaceFollowedBySpaceFollowedByChar({var0}))
[condition][]the interval between {fielddate1} and {fielddate2} is_equal_to {days}=((new DateCheck()).intervalBetweenTwoDateIsEqualtoDays({fielddate1},{fielddate2},{days}))
[condition][]presenceOfSpaceOtherThanSpecifiedPosition {var0} {var1} =((new Position()).presenceOfSpaceOtherThanSpecifiedPosition({var0},{var1}))
[condition][]the {field} is Prohibited for {commaseperatedvalues}=((new Prohibited()).prohibitedForValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]it is not true that_the {field} has {count} comma separated values=(!((new CommaSeparatedSpace()).countCommaSeperatedValues((xcb.xpath({field})).stringValue(),{count})))
[condition][]it is not true that_the{field} has_the last character not_equal_to_values{value}=(!((new Equals()).lastCharacterOfFieldNotEqualValues((xcb.xpath({field})).stringValue(),{value})))
[consequence][]setICSCLicense {var0} =((new SvcType()).setICSCLicense({var0}))
[condition][]it is not true that_for the Trading Partner with the ICSC {icscvalue} the {datevalue} falls on holiday=(!((new HOLIDAY()).fetchTPHoliday({icscvalue},{datevalue})))
[condition][]the {field} has_the specified {value} in the range {start} to {end}=((new RangeOfValues()).compareSpecStringInRange((xcb.xpath({field})).stringValue(),{value},{start},{end}))
[condition][]it is not true that_any of the occurance of {fieldwithxpath} exists=((new Occurence(xcb.getXmlInstance())).anyOccurenceExists({fieldwithxpath}))
[condition][]it is not true that_the_field {tagValue} is populated as per specified TLV format from positions 1 12 =(!((new Position()).formatCheckForFields1_12({tagValue})))
[condition][]it is not true that_the {field} contains roman numerals=(!((new Contains()).containsRoman((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_virtualoccOfF1POPnF2NOTPOPwithinsameUNIMAPPING {section} {errorcode} {field1} {field2} {field3} =(!(virtualoccOfF1POPnF2NOTPOPwithinsameUNIMAPPING({section},{errorcode},{field1},{field2},{field3})))
[condition][]it is not true that_noOfOccurancesOfTagValueIsUniqueForAnotherTagValueSet {var0} {var1} {var2} =((new Occurence(xcb.getXmlInstance())).noOfOccurancesOfTagValueIsUniqueForAnotherTagValueSet({var0},{var1},{var2}))
[condition][]the position_of Special Character is {pos} in {field}=((new DatatypeCheck()).checkPositionSP({pos},(xcb.xpath({field})).stringValue()))
[condition][]virtualIntegerToString {var0} =(virtualIntegerToString({var0}))
[condition][]it is not true that_The{field}matches with{compString}having the specified characters{numChar} from last within the comparison string=(!((new Position()).compnoOfCharAtLastWithTagValueAsPerCompString((xcb.xpath({field})).stringValue(),{compString},{numChar})))
[condition][]the_section{section} parent{parent} tag {tag} has_value{value} in any occurence=(virtualAnyOccurenceOfSaliTagEqualsValue({section},{parent},{tag},{value}))
[condition][]it is not true that_tagValueEqualsInPreviousVersion {var0} {var1} {var2} {var3} {var4} {var5} {var6} =(!((new SuplementOrderCheck()).tagValueEqualsInPreviousVersion({var0},{var1},{var2},{var3},{var4},{var5},{var6})))
[condition][]setICSCLicense {var0} =((new SvcType()).setICSCLicense({var0}))
[condition][]lrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues {var0} {var1} {var2} {var3} {var4} {var5} {var6} =((new Occurence(xcb.getXmlInstance())).lrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]it is not true that_the difference between {fielddate1} and {fielddate2} is greater than or equal to one year=(!((new DateCheck()).isRangeGreaterThanOrEqualToOneYear({fielddate1},{fielddate2})))
[condition][]all occurence of{section}{field} not_equals{value} erroring to last occurence with{errorcode}=(virtualAllOccurenceOfFieldNotEqualsValue({section},{field},{value},{errorcode}))
[condition][]it is not true that_the segment {segnum} length of field {fieldvalue} is in the range {min} and {max}=(!((new LengthCheck()).segmentNumberLengthInRange({segnum},{fieldvalue},{min},{max})))
[condition][]the {field} is compared with the specified {segnum} at the positions {pos1} to {pos2} with the specified {value}=((new Position()).compareSpecifiedSegmentWithCharPositionInValue((xcb.xpath({field})).stringValue(),{segnum},{pos1},{pos2},{value}))
[condition][]is dedicated recieve customer=((new SuplementOrderCheck()).checkDedicatedRecieveCustomer())
[condition][]it is not true that_the pon {field} ver {field} section {section} tag {tag} at {pos} is populated in Request against Response=(!((new SuplementOrderCheck()).checkResponseTagExistInRequestatPosition((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag},{pos})))
[condition][]the {field} from positions {pos1} to {pos2} is_not_populated and not spaces=((new Populated()).rangeOfPositionIsNotPopulatedAndNotSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2}))
[condition][]the {field} is Numeric with Special Characters Set {setofspecialcharacters}=((new DatatypeCheck()).checkNumericSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters}))
[condition][]the segment {segnum} length of the_field {fieldvalue} is in the range {min} and {max}=(virtualSegmentNumberLengthInRange({segnum},{fieldvalue},{min},{max}))
[condition][]the ccna{ccna} and icsc{icsc} combination exists=((new SuplementOrderCheck()).checkCcnaIcscCombination((xcb.xpath({ccna})).stringValue(),{icsc}))
[condition][]it is not true that_the_field value {field} do_not_matches the pattern {pattern}=(!((new SpecialFormat()).isPatternNotMatches((xcb.xpath({field})).stringValue(),{pattern})))
[condition][]the order is a resend order=((new SuplementOrderCheck()).resendOrderCheck())
[condition][]it is not true that_the segment {segnum} length of the_field {fieldvalue} is in the range {min} and {max}=(!(virtualSegmentNumberLengthInRange({segnum},{fieldvalue},{min},{max})))
[condition][]it is not true that_the CCNA has_license for CLLI Table=(!((new SvcType()).getCLLILicense()))
[condition][]the {pos} and {pos} position_of the {field} is greater than or equal to {pos} and {pos} position=((new Position()).twoPositionValueofTagIsGreaterThanOrEqualToTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]it is not true that_the {field} has_only one {char} special character present=(!((new DatatypeCheck()).checkRepeationOFSpecialCharacter((xcb.xpath({field})).stringValue(),{char})))
[condition][]the {field} has_specified segment {segnum} which contains alpha numeric characters with virgule or period as delimiter=((new DatatypeCheck()).virguleandPeriodSegmentEqualToAlphaNumeric((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is lesser than or equal to {pos} and {pos} position=(!((new Position()).twoPositionValueofTagIsLessThanOrEqualToTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]the {field} has_not a valid values {commaseperatedvalues}=((new isValidValue()).isNotValidValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]the {field} contains roman numerals=((new Contains()).containsRoman((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {fieldvalue} is in HHMMA HHMMP format and the difference is_equal_to or greater than {value} hours=(!((new TimeFormatCheck()).appointmentTimeFormatRange({fieldvalue},{value})))
[condition][]it is not true that_any occurrence of servpref {section}{subsect} populated=(!(virtualAnyOccurenceOfServPrefPopulated({section},{subsect})))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is greater than {pos} and {pos} position=(!((new Position()).twoPositionValueofTagIsGreaterThanTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]it is not true that_the {field} has_segment with specified {segnum} of the specified {length} to support virgule or period=(!((new LengthCheck()).virguleandPeriodSegmentNumberLengthEqualTo((xcb.xpath({field})).stringValue(),{segnum},{length})))
[condition][]it is not true that_number of occurences{fieldwithxpath} equals{value}=((new Occurence(xcb.getXmlInstance())).noOfOccurenceEqualsValue({fieldwithxpath},{value}))
[condition][]the {field} has {commaseperatedvalues}=((new ValidValueCheck()).validCommaSeperatedValue((xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]it is not true that_the icsc {fieldvalue} has_the license for the table {NCNCIICSCCLLI}=(!((new ASOGTABLE()).checkIcscLicenseForTable({fieldvalue},{NCNCIICSCCLLI})))
[condition][]it is not true that_the difference between {fielddate1} and {fielddate2} is greater than specified {fieldmonths}=(!((new DateCheck()).isRangeGreaterThanSpecifiedMonths({fielddate1},{fielddate2},{fieldmonths})))
[condition][]the {field} is Alpha=((new DatatypeCheck()).checkAlpha((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_checkResponsePonDoesNotExistInRequest {var0} {var1} {var2} =(!((new SuplementOrderCheck()).checkResponsePonDoesNotExistInRequest({var0},{var1},{var2})))
[condition][]it is not true that_the {field} has_space as a special character=(!((new SpaceCheck()).spaceAsSpecialCharacter((xcb.xpath({field})).stringValue())))
[condition][]the {field} not_equals {value}=((new Equals()).isNotEquals((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {field} not_equals {value}=(!((new Equals()).isNotEquals((xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_the {fieldwithxpath} is not prohibited=(!((new Prohibited()).isNotProhibited({fieldwithxpath})))
[consequence][]setICSCNCNCICompatibilityLicense {var0} =((new SvcType()).setICSCNCNCICompatibilityLicense({var0}))
[condition][]the_section EVC {section} with sub section {subsect} for the field {field} is not conecutively assigned starting with {value} then errorcode {errorcode}=(virtuallrefIsNotConecutivelyAssignedStratingWIthValue({section},{subsect},{field},{value},{errorcode}))
[condition][]duplicate order pon {pon} ver {ver} ccna {ccna} icsc {icsc} exists in DB=((new SuplementOrderCheck()).duplicateOrderCheck((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc}))
[condition][]it is not true that_the {field} has_the specified segment with number {segnum} whose length is in range {min} to {max} with leading spaces to support virgule or period as delimiter=(!((new LengthCheck()).virguleandPeriodSegmentRangeIsNumericWithLeadingSpaces((xcb.xpath({field})).stringValue(),{segnum},{min},{max})))
[condition][]it is not true that_virguleFollowedByVirgule {var0} =(!((new Contains()).virguleFollowedByVirgule({var0})))
[condition][]it is not true that_the pos {pos} to {pos} of segment {segnum} of the_field {field} does not_equal_to_values {commaseparatedvalues}=(!((new LengthCheck()).posToPosOfSegmentNotEquals({pos},{pos},{segnum},(xcb.xpath({field})).stringValue(),{commaseparatedvalues})))
[condition][]the {field} having last {N} characters {chars} are preced by numeric=((new Equals()).lastNcharsprecededbynumeric((xcb.xpath({field})).stringValue(),{N},{chars}))
[condition][]checkCancelledUrefExists {var0} {var1} {var2} {var3} {var4} {var5} {var6} =((new SuplementOrderCheck()).checkCancelledUrefExists({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]the {field} has {N} number of segments=((new LengthCheck()).fieldHasNumberOfSegments((xcb.xpath({field})).stringValue(),{N}))
[condition][]The number of occurence of {path} populated is greater than {number}=((new Occurence(xcb.getXmlInstance())).NumberOfoccurencepopulatedisgreaterthan({path},{number}))
[condition][]virtualoccurenceofuactNCI {vector} {list} {ncivalue} {errorcode} =(virtualoccurenceofuactNCI({vector},{list},{ncivalue},{errorcode}))
[condition][]The field Date is a valid date in the format mmddyy=((new DateCheck()).isValidDate2())
[condition][]checkTagValue pon {field} ver {field} ccna {field} icsc {field} section {section} tag {tag} equalsvalue {value} pos {pos}InRequestforResponse=((new SuplementOrderCheck()).checkTagValueInRequestforResponse((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag},{value},{pos}))
[condition][]it is not true that_cktActCheckWithPrevVer {var0} {var1} {var2} {var3} {var4} {var5} {var6} =(!((new SuplementOrderCheck()).cktActCheckWithPrevVer({var0},{var1},{var2},{var3},{var4},{var5},{var6})))
[condition][]the_section {section} {field} is populated in any occurence with {errorcode}=(virtualFieldIsPopulated({section},{field},{errorcode}))
[condition][]it is not true that_the {fielddate1} is a working day=(!((new DateCheck()).isWorkingDay({fielddate1})))
[condition][]noOfOccurancesOfTagValueIsUniqueForAnotherTagValueSet {var0} {var1} {var2} =((new Occurence(xcb.getXmlInstance())).noOfOccurancesOfTagValueIsUniqueForAnotherTagValueSet({var0},{var1},{var2}))
[condition][]the {field} has_telephone number format as {tnformat}=((new TNFormat()).tnFormatIs((xcb.xpath({field})).stringValue(),{tnformat}))
[condition][]it is not true that_the_field{field} with segment{segment} equals{value}=(!((new Position()).compareSpecifiedSegmentWithValue((xcb.xpath({field})).stringValue(),{segment},{value})))
[condition][] new ReqTypeAct  getRequestType  =((new ReqTypeAct()).getRequestType())
[condition][]it is not true that_characterFollowedBySpace {var0} {var1} =(!((new Contains()).characterFollowedBySpace({var0},{var1})))
[condition][]the {fielddate1} is less than or equal to {fielddate2}=((new DateCheck()).isLessThanOrEqualTo({fielddate1},{fielddate2}))
[condition][]qtyCheckForCktact {var0} {var1} {var2} =((new Occurence(xcb.getXmlInstance())).qtyCheckForCktact({var0},{var1},{var2}))
[condition][]the {field} contains {num} of consecutive spaces after Alpha Characters=((new CapitalLetterCheck()).containsConsecutiveSpacesAfterAlphaCharacters((xcb.xpath({field})).stringValue(),{num}))
[condition][]it is not true that_the_section{section} parent{parent} tag {tag} does not have value{value} in any occurence=(!(virtualNoneOccurenceEqualsValue({section},{parent},{tag},{value})))
[condition][]any_occurance_of_the {fieldwithxpath} is_not_equal_to {values} values=((new Occurence(xcb.getXmlInstance())).anyOccurenceNotEqualToValues({fieldwithxpath},{values}))
[condition][]it is not true that_any_occurance_of_the {fieldwithxpath} is_not_equal_to {values} values=((new Occurence(xcb.getXmlInstance())).anyOccurenceNotEqualToValues({fieldwithxpath},{values}))
[condition][]the icsc {fieldvalue} has_the license for the table {NCNCIICSCCLLI}=((new ASOGTABLE()).checkIcscLicenseForTable({fieldvalue},{NCNCIICSCCLLI}))
[condition][]positionOfAnyFieldNotEqualToCharacter {var0} {var1} {var2} =((new Occurence(xcb.getXmlInstance())).positionOfAnyFieldNotEqualToCharacter({var0},{var1},{var2}))
[condition][]it is not true that_any_occurance_of_the {field1withxpath} is_equal_to comma seperated values{values}=((new Occurence(xcb.getXmlInstance())).anyOccurenceEqualToValues({field1withxpath},{values}))
[condition][]Is the {field} of the specified segment {segnum} is in the range 00 999=((new RangeOfValues()).segmentRangeCheck00_999((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]any occurance of {fieldwithxpath} is there=((new Occurence(xcb.getXmlInstance())).anyOccurenceOf({fieldwithxpath}))
[condition][]the_field differs from previous version for the pon {PON} version {VER} icsc{ICSC} and ccna{CCNA} {fieldname} of {parentname} at pos{POS} with fieldvalue {fieldvalue}=((new SuplementOrderCheck()).fieldDiffersFromPreviousVersionatspecpos((xcb.xpath({PON})).stringValue(),(xcb.xpath({VER})).stringValue(),{ICSC},(xcb.xpath({CCNA})).stringValue(),{fieldname},{parentname},{POS},{fieldvalue}))
[condition][]segmentValueEqualToValues {var0} {var1} {var2} =((new Equals()).segmentValueEqualToValues({var0},{var1},{var2}))
[condition][]no of occurences of tag {fieldxpath1} with {field1} and {fieldxpath2} with {field2} are equal=((new Occurence(xcb.getXmlInstance())).noOfOccurencesOfBothTagAreEqualForSpecifiedPairValue({fieldxpath1},{field1},{fieldxpath2},{field2}))
[condition][]it is not true that_getLatestVersion {var0} {var1} =(!((new SuplementOrderCheck()).getLatestVersion({var0},{var1})))
[condition][]it is not true that_the {fielddate1} is_not_equal_to {fielddate2}=(!((new DateCheck()).isNotEqualTo({fielddate1},{fielddate2})))
[condition][]the {field} has_three consecutive uppercase alphabets=((new CapitalLetterCheck()).threeConsecutiveUpperCaseAlpha((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_segmentValueEqualToValues {var0} {var1} {var2} =(!((new Equals()).segmentValueEqualToValues({var0},{var1},{var2})))
[condition][]the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} on the current order and matching with the previous order which has_a status CANCEL=((new SuplementOrderCheck()).supFieldCheck({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue}))
[condition][]it is not true that_allLowerCase {var0} =(!((new CapitalLetterCheck()).allLowerCase({var0})))
[condition][]it is not true that_allOccurenceOfFieldEqualToValue {var0} {var1} =((new Occurence(xcb.getXmlInstance())).allOccurenceOfFieldEqualToValue({var0},{var1}))
[condition][]the{section} {field} is not unique in all the occurences with code {code}=((new Occurence(xcb.getXmlInstance())).isUnique({section},{field},{code}))
[condition][]the {field} has_the specified segment with number {segnum} whose length is in range {min} to {max} with leading spaces to support virgule or period as delimiter=((new LengthCheck()).virguleandPeriodSegmentRangeIsNumericWithLeadingSpaces((xcb.xpath({field})).stringValue(),{segnum},{min},{max}))
[condition][]it is not true that_compareICSCForMultiEC pon {PON} ccna {CCNA} version {VER}section {COLL} tagname {TAG} description {DESC}=(!((new SuplementOrderCheck()).compareICSCForMultiEC((xcb.xpath({PON})).stringValue(),(xcb.xpath({CCNA})).stringValue(),(xcb.xpath({VER})).stringValue(),{COLL},{TAG},{DESC})))
[condition][]the {fieldvalue} is present on ICSC table=((new ASOGTABLE()).fetchAbbreviationICSCTable({fieldvalue}))
[condition][]the {field} is Alpha with Special Characters Set {setofspecialcharacters}=((new DatatypeCheck()).checkAlphaSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters}))
[condition][]the {pos} position_of {field} field_is_equal_to_values {commaseperatedvalues}=((new Position()).positionOftagValueEqualToValues({pos},(xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]the {fielddate1} is greater than {fielddate2}=((new DateCheck()).isGreaterThan({fielddate1},{fielddate2}))
[condition][]it is not true that   new ReqTypeAct  getRequestType  =(!((new ReqTypeAct()).getRequestType()))
[condition][]it is not true that_the {field} has_alpha characters in the specified range {start} to {end}=(!((new RangeOfValues()).numberOfAlphaInSpecRange((xcb.xpath({field})).stringValue(),{start},{end})))
[condition][]the {field} from positions {pos1} to {pos2} is populated or not spaces=((new Populated()).rangeOfPositionIsPopulatedOrNotSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2}))
[condition][]the {field} has_date format as check3 {YYMMDD}=((new DateFormatCheck()).dateCheck3((xcb.xpath({field})).stringValue(),{YYMMDD}))
[condition][]it is not true that_the no of occurances of {fieldxpath} pair have different {fieldxpath} values=((new Occurence(xcb.getXmlInstance())).noOfOccurancesOfLactIOPairMustHaveDiffAliValue({fieldxpath},{fieldxpath}))
[condition][]it is not true that_any occurance of {fieldwithxpath} is there=((new Occurence(xcb.getXmlInstance())).anyOccurenceOf({fieldwithxpath}))
[condition][]it is not true that_the interval duration is blank for the {ccna} {nc} and {icsc}=(!((new IntervalDurationMatcher()).isIntervalExisting((xcb.xpath({ccna})).stringValue(),{nc},{icsc})))
[condition][]virtualoccOfVPNIDnSVLANSTARTnASNwithinsameUNIMAPPING {section} {errorcode} =(virtualoccOfVPNIDnSVLANSTARTnASNwithinsameUNIMAPPING({section},{errorcode}))
[condition][]it is not true that_qtyCheckForCktact {var0} {var1} {var2} =((new Occurence(xcb.getXmlInstance())).qtyCheckForCktact({var0},{var1},{var2}))
[condition][]virtualoccurenceofVACTandUACT2CEVLAN {var0} {var1} =(virtualoccurenceofVACTandUACT2CEVLAN({var0},{var1}))
[condition][]it is not true that_the_field {field} is not numeric from postion {posn1} to position {posn2}=(!((new Contains()).positionalNotNumeric((xcb.xpath({field})).stringValue(),{posn1},{posn2})))
[condition][]it is not true that_the position_ {pos} of {field} is_not_equal_to {value}=(!((new Position()).positionOftagValueNotEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_confirmationOrderCheck pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=(!((new SuplementOrderCheck()).confirmationOrderCheck((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{description})))
[condition][]the interval between {fielddate1} and {fielddate2} is less than {days}=((new DateCheck()).intervalBetweenTwoDateIsLessThanDays({fielddate1},{fielddate2},{days}))
[condition][]from the {pos1} to {pos2} has {format} for the {field}=((new DateFormatCheck()).time_format_chk({pos1},{pos2},{format},(xcb.xpath({field})).stringValue()))
[condition][]the {field} is AlphaNumeric=((new DatatypeCheck()).checkAlphaNumeric((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} is according to the specified {format}=(!((new SpecialFormat()).isFieldAccordingToFormat((xcb.xpath({field})).stringValue(),{format})))
[condition][]the {field} has_none valid values {commaseperatedvalues}=((new isValidValue()).isNoneValidValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]the difference between {fielddate1} and {fielddate2} is greater than one year=((new DateCheck()).isRangeGreaterThanOneYear({fielddate1},{fielddate2}))
[condition][]the {pos} and {pos} of {field} is_equal_to_values {CommaSeparatedValues}=((new Position()).twoPositionValueofTagEqualToValues({pos},{pos},(xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]it is not true that_the {pos} position_of {field} field_is_equal_to_values {commaseperatedvalues}=(!((new Position()).positionOftagValueEqualToValues({pos},(xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]any occurence of the {fieldwithxpath} is populated in Response=((new Occurence(xcb.getXmlInstance())).anyOccurenceOfFieldPopulatedInRespose({fieldwithxpath}))
[condition][]it is not true that_the {field} does not match with {field2} at the specified character positions {pos1} to {pos2}=(!((new Position()).compStringDoesntMatchTagValueAtSpecPosition((xcb.xpath({field})).stringValue(),{field2},{pos1},{pos2})))
[condition][]it is not true that_the_field {field1} is greater than field {field2}=(!((new Equals()).field1IsGreaterThanField2({field1},{field2})))
[condition][]getSaliParent of{parent} in{section} for{tag}=((new Occurence(xcb.getXmlInstance())).getSaliParent({parent},{section},{tag}))
[condition][]virguleFollowedByVirgule {var0} =((new Contains()).virguleFollowedByVirgule({var0}))
[condition][]it is not true that_the occurance of {fieldwithxpath} is_equal_to {number}=((new Occurence(xcb.getXmlInstance())).noOfOccurenceEqualTo({fieldwithxpath},{number}))
[condition][]it is not true that_the {fieldvalue} is present in NCMUX table =(!((new ASOGTABLE()).fetchAbbreviationNCMUXTable({fieldvalue})))
[condition][]it is not true that_the difference between {fielddate1} and {fielddate2} is greater than one year=(!((new DateCheck()).isRangeGreaterThanOneYear({fielddate1},{fielddate2})))
[condition][]Check for reqtyp{field} pon{field}ver{ver}ccna{ccna}icsc{icsc}=((new SuplementOrderCheck()).reqtypFieldCheck((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc}))
[condition][]the {pos} and {pos} of {field} is_not_equal_to_values {CommaSeparatedValues}=((new Position()).twoPositionValueofTagNotEqualToValues({pos},{pos},(xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]it is not true that_the {field} contains {num} of spaces before Alpha Characters=(!((new CapitalLetterCheck()).containsConsecutiveSpacesBeforeAlphaCharacters((xcb.xpath({field})).stringValue(),{num})))
[condition][]it is not true that_the {field} has_no values{commaseperatedvalues} in the segment{segnum} to support virgule or period as delimiter=(!((new Equals()).virguleandPeriodSegmentValueNotEqualToValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues},{segnum})))
[condition][]isRequired {var0} =((new Required()).isRequired({var0}))
[condition][]it is not true that_the {field} has_format as {format}=(!((new SpecialFormat()).formatIs((xcb.xpath({field})).stringValue(),{format})))
[condition][]it is not true that_any occurence of {section}{field} is_not_populated with {errorcode}=((new Occurence(xcb.getXmlInstance())).VirtualAnyOccurenceIsNotPopulated({section},{field},{errorcode}))
[condition][]the {field} has_date format check1 {format1}=((new DateFormatCheck()).dateCheck1((xcb.xpath({field})).stringValue(),{format1}))
[condition][]compareICSCForMultiEC pon {PON} ccna {CCNA} version {VER}section {COLL} tagname {TAG} description {DESC}=((new SuplementOrderCheck()).compareICSCForMultiEC((xcb.xpath({PON})).stringValue(),(xcb.xpath({CCNA})).stringValue(),(xcb.xpath({VER})).stringValue(),{COLL},{TAG},{DESC}))
[condition][]tag value of the request order for the pon{pon} ver{ver} ccna{ccna} icsc{icsc} section{section} tag{tag} not_equals {value}=((new SuplementOrderCheck()).requestDoesNothaveTheTagValue((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{section},{tag},{value}))
[condition][]numericCheckFormat {var0} {var1} {var2} =((new SpecialFormat()).NumericCheckFormat({var0},{var1},{var2}))
[condition][]any occurence of multiple {field} is populated=((new Occurence(xcb.getXmlInstance())).anyOccurenceOfMultipleFieldIsPopulated({field}))
[condition][]the CCNA has_license for NCNCICOMPATIBILITY Table=((new SvcType()).getNCNCICompatibilityLicense())
[condition][]it is not true that_the {field} is equal or greater than {value}=(!((new Equals()).isEqualOrGreaterThan((xcb.xpath({field})).stringValue(),{value})))
[condition][]virtualCanopiWebService {var0} =(virtualCanopiWebService({var0}))
[condition][]it is not true that_checkResponse_IcscTagExistInRequestIcsc {var0} {var1} {var2} {var3} =(!((new SuplementOrderCheck()).checkResponse_IcscTagExistInRequestIcsc({var0},{var1},{var2},{var3})))
[condition][]the {fieldwithxpath} occurance is atleast {numberoftimes}=((new Occurence(xcb.getXmlInstance())).atleastOccurenceOf({fieldwithxpath},{numberoftimes}))
[condition][]it is not true that_display the message {field}=(!((new DisplayMessage()).displayMessage((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the value of{field} is_not_equal_to occurence of the {fieldwithxpath}=((new Occurence(xcb.getXmlInstance())).valueOfFieldIsNotEqualToccurenceOfAnotherField({field},{fieldwithxpath}))
[condition][]it is not true that_virtualoccurenceofVACTandUACT2 {section} {errorcode} =(!(virtualoccurenceofVACTandUACT2({section},{errorcode})))
[condition][]it is not true that_the {fieldvalue} is populated in segment {segnum} after {value}=(!(virtualPositionAfterDelimeterPopulated({fieldvalue},{segnum},{value})))
[condition][]the {field} not_equal_to specified {value} of the specified {segnum}=((new Equals()).segmentValueNotEqualToEnteredValue((xcb.xpath({field})).stringValue(),{value},{segnum}))
[condition][]it is not true that_the ccna {fieldvalue} has_the license for the table {NCNCIICSCCLLI}=(!((new ASOGTABLE()).checkCcnaLicenseForTable({fieldvalue},{NCNCIICSCCLLI})))
[condition][]it is not true that_the {field} has_the segment with specified {segnum} whose length is greater than specified {length}=(!((new LengthCheck()).segmentNumberLengthGreaterThan((xcb.xpath({field})).stringValue(),{segnum},{length})))
[condition][]it is not true that_the {field} contains numeric characters=(!((new Contains()).containsNumeric((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the_field {field} with space in range {start} and {end}=(!((new SpaceCheck()).existenceOfSpaceInSpecRange((xcb.xpath({field})).stringValue(),{start},{end})))
[condition][]it is not true that_noConfirmationOrderCheck {var0} {var1} {var2} {var3} =(!((new SuplementOrderCheck()).noConfirmationOrderCheck({var0},{var1},{var2},{var3})))
[condition][]the_section {field} is_not_populated=((new Populated()).isNotPopulated((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_Is the {fieldDate1} less than {comparisonDate} in the format {CCYYMMDD}=(!((new DateFormatCheck()).isFieldDateLessThanComparisonDateInspecifiedFormat({fieldDate1},{comparisonDate},{CCYYMMDD})))
[condition][]the occurance of {fieldwithxpath} is greaterthan {number}=((new Occurence(xcb.getXmlInstance())).noOfOccurenceGreaterThan({fieldwithxpath},{number}))
[condition][]{xpath} is unique=((new Unique()).isUnique({xpath}))
[condition][]noOfOccurenceGreaterThanValue {var0} {var1} =((new Occurence(xcb.getXmlInstance())).noOfOccurenceGreaterThanValue({var0},{var1}))
[condition][]it is not true that_the difference for the given {CCNA} {NC} and {ICSC} between the {ASRDDD} and the current date is less than the Interval Duration from the table=(!((new IntervalDurationMatcher()).isIntervalDurationMatching((xcb.xpath({CCNA})).stringValue(),{NC},{ICSC},{ASRDDD})))
[condition][]it is not true that_isRequired {var0} =(!((new Required()).isRequired({var0})))
[condition][]it is not true that_the {field} from {pos1} to {pos2} of the segment{segnum} has_the comma seperated values{values} to support virgule or period as delimiter=(!((new LengthCheck()).virguleandPeriodPosToPosOfSegmentNotEquals((xcb.xpath({field})).stringValue(),{pos1},{pos2},{segnum},{values})))
[condition][]it is not true that_checkValidatedAndTransmittedRequestInDatabase pon {field} ver {field} ccna {field} icsc {field} =(!((new SuplementOrderCheck()).checkValidatedAndTransmittedRequestInDatabase((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {fielddate1} is a valid date=(!((new DateCheck()).isValidDate({fielddate1})))
[condition][]the {fieldwithxpath} is prohibited=((new Prohibited()).isProhibited({fieldwithxpath}))
[condition][]it is not true that_anyOccurenceSection{sect}WithTag1{tag1}NotpopulatedAndTag2{tag2}Populatedwith errorcode{errorcode}=(!(virtualanyOccurenceWithTag1NotpopulatedAndTag2Populated({sect},{tag1},{tag2},{errorcode})))
[condition][]it is not true that_the_field differs from previous version for the pon {PON} version {VER} icsc{ICSC} and ccna{CCNA} {fieldname} of {parentname} at pos{POS} with fieldvalue {fieldvalue}=(!((new SuplementOrderCheck()).fieldDiffersFromPreviousVersionatspecpos((xcb.xpath({PON})).stringValue(),(xcb.xpath({VER})).stringValue(),{ICSC},(xcb.xpath({CCNA})).stringValue(),{fieldname},{parentname},{POS},{fieldvalue})))
[condition][]the {field} does not contain {CommaSeparatedValues}=((new Contains()).doesNotContains((xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]it is not true that_setNCILicense {var0} =(!((new SvcType()).setNCILicense({var0})))
[condition][]it is not true that_the {pos} position_of {field} is_equal_to {value}=(!((new Position()).positionOftagValueEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value})))
[condition][]the {field} with segment{segnum} is populated=((new DatatypeCheck()).segmentPopulated((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]the {field} has_specified {segmentNumber} field not_equal_to alpha=((new DatatypeCheck()).segmentNotEqualToAlpha((xcb.xpath({field})).stringValue(),{segmentNumber}))
[condition][]any occurence of{fieldwithxpath} is_not_populated=((new Occurence(xcb.getXmlInstance())).anyOccurenceOfFieldNotPopulated({fieldwithxpath}))
[condition][]it is not true that_the {pos} position_Of {field} equal to {value}=(!((new Contains()).positionOfFieldEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value})))
[condition][]getLatestVersion {var0} {var1} =((new SuplementOrderCheck()).getLatestVersion({var0},{var1}))
[condition][]all occurences of {section} of field {field} equals the value{value} with errorcode {errorcode}=(virtualAllOccurenceOfFieldEqualsValue({section},{field},{value},{errorcode}))
[condition][]it is not true that_is dedicated recieve customer=(!((new SuplementOrderCheck()).checkDedicatedRecieveCustomer()))
[condition][]the {field} from positions {pos1} to {pos2} is populated or spaces=((new Populated()).rangeOfPositionIsPopulatedOrSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2}))
[condition][]it is not true that_the {pos} position_Of {field1} equal to {pos} position_Of {field2}=(!((new Contains()).positionOfFieldEqualToPositionOfField({pos},{field1},{pos},{field2})))
[condition][]it is not true that_the difference between {fielddate1} and {fielddate2} is_equal_to one year=(!((new DateCheck()).isRangeEqualToOneYear({fielddate1},{fielddate2})))
[condition][]it is not true that_isCurrentDateLessThanOrEqualToDesiredDueDate {var0} =(!((new DateCheck()).isCurrentDateLessThanOrEqualToDesiredDueDate({var0})))
[condition][]the {field} is greater than {value}=((new Equals()).isGreaterThan((xcb.xpath({field})).stringValue(),{value}))
[consequence][]setIcscCLLILicense {var0} =((new SvcType()).setIcscCLLILicense({var0}))
[condition][]it is not true that_the CCNA has_license for NC Table=(!((new SvcType()).getNCLicense()))
[condition][]the interval between {fielddate1} and {fielddate2} is greater than or equal to {days}=((new DateCheck()).intervalBetweenTwoDateIsGreaterThanOrEqualToDays({fielddate1},{fielddate2},{days}))
[condition][]it is not true that_the {field} is AlphaNumeric without following Special Character set {setofspecialcharacters}=(!((new DatatypeCheck()).checkAlphaNumericWithOutSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters})))
[condition][]it is not true that_the {field} is numeric followed by dot and is followed by numeric=(!((new RangeOfValues()).isNumericFollowedByDotFollowedByNumeric((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_tag value of the request order for the pon{pon} ver{ver} ccna{ccna} icsc{icsc} section{section} tag{tag} not_equals {value}=(!((new SuplementOrderCheck()).requestDoesNothaveTheTagValue((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{section},{tag},{value})))
[condition][]the {field}is_not_equal_to_values {CommaSeparatedValues}=((new Equals()).isNotEqualToValues((xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]the {field} has_segment with specified {segnum} of the specified {length}=((new LengthCheck()).segmentNumberLengthEqualTo((xcb.xpath({field})).stringValue(),{segnum},{length}))
[condition][]the {field} has_time format as {timeformat}=((new TimeFormatCheck()).timeFormat((xcb.xpath({field})).stringValue(),{timeformat}))
[condition][]it is not true that_Is the {field} of the specified segment {segnum} is in the range 00 999=(!((new RangeOfValues()).segmentRangeCheck00_999((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]it is not true that_spaceFollowedBySpace {var0} =(!((new Contains()).spaceFollowedBySpace({var0})))
[condition][]it is not true that_the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} on the current order and does not have same {CCNAICSC} on the previous order=(!((new SuplementOrderCheck()).checkCcnaIcscActWithPreviousVersion({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue},{CCNAICSC})))
[condition][]it is not true that_the {field} is equal or less than {value}=(!((new Equals()).isEqualOrLessThan((xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_the {field} contains invalid values or with valid values {commaseparatedvalues} without spaces between them or repeated=(!((new Contains()).containsInvalidOrValidWithoutSpaceOrRepeated((xcb.xpath({field})).stringValue(),{commaseparatedvalues})))
[condition][]it is not true that_the {section}{field} is_not_populated in all occurence=((new Occurence(xcb.getXmlInstance())).VirtualNoOccurenceIsPopulated({section},{field}))
[condition][]the {field} has_the specified segment with number {segnum} whose length is less than specified {length}=((new LengthCheck()).segmentNumberLengthLessThan((xcb.xpath({field})).stringValue(),{segnum},{length}))
[condition][]it is not true that_getLatestValidVersionInDataBaseWithStatus {var0} {var1} {var2} =(!((new SuplementOrderCheck()).getLatestValidVersionInDataBaseWithStatus({var0},{var1},{var2})))
[condition][]lrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue {var0} {var1} {var2} {var3} {var4} {var5} {var6} =((new Occurence(xcb.getXmlInstance())).lrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]it is not true that_numericCheckFormat {var0} {var1} {var2} =(!((new SpecialFormat()).NumericCheckFormat({var0},{var1},{var2})))
[condition][]it is not true that_the {field} has_both uppercase and lowercase characters for comma seperated vaules=(!((new CapitalLetterCheck()).isUpperAndLowerCaseForCSV((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {fielddate1} is less than {fielddate2}=(!((new DateCheck()).isLessThan({fielddate1},{fielddate2})))
[condition][]it is not true that_the {field} is Prohibited=(!((new Prohibited()).isProhibited((xcb.xpath({field})).stringValue())))
[condition][]isValidDate1 {var0} =((new DateCheck()).isValidDate1({var0}))
[condition][]it is not true that_the {field} has_not a valid values {commaseperatedvalues}=(!((new isValidValue()).isNotValidValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][] new SvcType  getSvcName  =((new SvcType()).getSvcName())
[condition][]it is not true that_{xpath} is unique=(!((new Unique()).isUnique({xpath})))
[condition][]the {field} has_virgule or period as delimiter=((new DatatypeCheck()).fieldHasOneDelimiter((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_CHECK FIRMORDER request{field} pon{field} ver{field} ccna{field} icsc{field}=(!((new SuplementOrderCheck()).firmOrderToServiceRequestCheck((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the version {VER} is not one greater than the previous database version for the pon {PON} ccna {CCNA} and icsc {ICSC} with status {status}=(!((new SuplementOrderCheck()).verNotOneGreaterThanLatestDBVersion((xcb.xpath({VER})).stringValue(),(xcb.xpath({PON})).stringValue(),(xcb.xpath({CCNA})).stringValue(),{ICSC},{status})))
[condition][]the_field {field} has_pattern {pattern}=((new SpecialFormat()).patternChecking((xcb.xpath({field})).stringValue(),{pattern}))
[condition][]it is not true that_the {field} has_specified {segmentNumber} field not_equal_to alpha=(!((new DatatypeCheck()).segmentNotEqualToAlpha((xcb.xpath({field})).stringValue(),{segmentNumber})))
[condition][]it is not true that_the {field} has_specified segment {segnum} which contains alpha numeric characters=(!((new DatatypeCheck()).segmentEqualToAlphaNumeric((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]the {field} with segment {segnum} is_not_populated=((new Populated()).segmentIsNotPopulated((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]the {fielddate1} is a Weekend=((new DateCheck()).isHoliday({fielddate1}))
[condition][]getRootXpath=((new Occurence(xcb.getXmlInstance())).getRootXpath())
[condition][]confirmationOrderCheck {var0} {var1} {var2} {var3} =((new SuplementOrderCheck()).confirmationOrderCheck({var0},{var1},{var2},{var3}))
[condition][]the CKTACT field check pon{pon} ver{ver} ccna{ccna} icsc{icsc} and xpath{xpath} tag{tag} with value{value} for rule{ruleErrorCode}=((new Occurence(xcb.getXmlInstance())).cktActCheck((xcb.xpath({pon})).stringValue(),(xcb.xpath({ver})).stringValue(),(xcb.xpath({ccna})).stringValue(),{icsc},{xpath},{tag},{value},{ruleErrorCode}))
[condition][]it is not true that_anyOccurenceOf{section}{tag} equals {commaseperatedvalues}=(!(virtualfieldEqualsValues({section},{tag},{commaseperatedvalues})))
[condition][]any occurrence of servpref {section}{subsect} populated=(virtualAnyOccurenceOfServPrefPopulated({section},{subsect}))
[condition][]for the Trading Partner with the ICSC {icscvalue} the {datevalue} falls on holiday=((new HOLIDAY()).fetchTPHoliday({icscvalue},{datevalue}))
[condition][]the interval between {fielddate1} and {fielddate2} is_not_equal_to {days}=((new DateCheck()).intervalBetweenTwoDateIsNotEqualtoDays({fielddate1},{fielddate2},{days}))
[condition][]it is not true that_the_field {field} with segment {segnum} is populated=(!((new Populated()).segmentIsPopulated((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]it is not true that_virtualisIntervalDurationMatchingForNc {var0} {var1} =(!(virtualisIntervalDurationMatchingForNc({var0},{var1})))
[condition][]it is not true that_segmentRangeIsNumericWithLeadingSpaces {var0} {var1} {var2} {var3} =(!((new LengthCheck()).segmentRangeIsNumericWithLeadingSpaces({var0},{var1},{var2},{var3})))
[condition][]the value of{field} is_not_equal_to occurence of the {fieldwithxpath}=((new Occurence(xcb.getXmlInstance())).valueOfFieldIsNotEqualToccurenceOfAnotherField({field},{fieldwithxpath}))
[condition][]it is not true that_the {field} is greater than {value}=(!((new Equals()).isGreaterThan((xcb.xpath({field})).stringValue(),{value})))
[condition][]the {field} has_all uppercase characters for comma seperated values=((new CapitalLetterCheck()).isAllUpperCaseForCSV((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} is NotProhibited=(!((new Prohibited()).isNotProhibited((xcb.xpath({field})).stringValue())))
[condition][]the position_of Numeric is {pos} in {field}=((new DatatypeCheck()).checkPositionNumeric({pos},(xcb.xpath({field})).stringValue()))
[condition][]it is not true that_lrefTagCheck {var0} {var1} {var2} {var3} =(!((new SuplementOrderCheck()).lrefTagCheck({var0},{var1},{var2},{var3})))
[condition][]it is not true that_the {fielddate1} is_equal_to {fielddate2}=(!((new DateCheck()).isEqualTo({fielddate1},{fielddate2})))
[condition][]the {pos} position_of {field} is_not_equal_to {value}=(virtualPositionOftagValueNotEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {field} has_time format as {timeformat}=(!((new TimeFormatCheck()).timeFormat((xcb.xpath({field})).stringValue(),{timeformat})))
[condition][]it is not true that_the position_of Numeric is {pos} in {field}=(!((new DatatypeCheck()).checkPositionNumeric({pos},(xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} from positions {pos1} to {pos2} is populated or spaces=(!((new Populated()).rangeOfPositionIsPopulatedOrSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2})))
[consequence][]the error code {field1} the error message {field2} for the field {field3}=(xcb.logError({field1},{field2},{field3}))
[consequence][]the error code {field1} the error message {field2}=(xcb.logError({field1},{field2}))
[condition][]the {section} {field} is not unique in all the occurences with errorCode {errorcode} and errorMessage {errormessage}=FieldShouldNotUnique(xcb,{section},{field},{errorcode},{errormessage})
[condition][]xcb object=xcb : XOMContainerBean()
[condition][]Evaluate=eval
[condition][]Start Brace=(
[condition][]End Brace=)
[condition][]AND=&&
[condition][]OR=||
